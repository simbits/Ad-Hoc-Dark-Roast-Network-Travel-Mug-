4DGL Compiler 2.6.0.4 -- Copyright 2004-2010 4D Labs
** C:\Users\simon\Desktop\mugDisplay3\mugDisplay\mugDisplay.4DG compiled Sun Jun 19 09:59:48 2011

file C:\Users\simon\Desktop\mugDisplay3\mugDisplay\mugDisplay.4DG

file C:\Program Files (x86)\4D Labs\4D Workshop 3 IDE\include\GOLDELOX-GFX2.fnc

0001  0001             #platform "GOLDELOX-GFX2"
0002  0001             #platform "GOLDELOX-GFX2"
0003  0007             */
0004  0010             */
0005  0011   
0006  0012                 // for Goldelox GFX2
0007  0013   
0008  0014                 #constant GOLDELOX      1
0009  0014                 #constant GOLDELOX      1
0010  0015   
0011  0016                 #constant __MAXMEM      255
0012  0016                 #constant __MAXMEM      255
0013  0017                 #constant __MAXPROG     9216
0014  0017                 #constant __MAXPROG     9216
0015  0018   
0016  0019                 #constant __PLATFORM    GOLDELOX
0017  0019                 #constant __PLATFORM    GOLDELOX
0018  0020   
0019  0021   
0020  0022   
0021  0023   
0022  0024             //==============================================//
0023  0025             // initialization table additional commands     //
0024  0026             //==============================================//
0025  0027             #CONST
0026  0037             #END
0027  0038   
0028  0039             //==============================================//
0029  0040             // putch, putstr, putnum and print redirection  //
0030  0041             // constants                                    //
0031  0042             //==============================================//
0032  0043             #CONST
0033  0048             #END
0034  0049   
0035  0050             //==============================================//
0036  0051             // general number formatting constants          //
0037  0052             // for 'print' and 'putnum'                     //
0038  0053             //==============================================//
0039  0054             #CONST
0040  0186             #END
0041  0187   
0042  0188             // baud divisor rates
0043  0189             #CONST
0044  0211             #END
0045  0212   
0046  0213   
0047  0214   
0048  0219             */
0049  0220   
0050  0221   
0051  0222             //==============================================//
0052  0223             // EVE bios functions                           //
0053  0224             //==============================================//
0054  0225   
0055  0226             func serin(), 1;                                // read a byte from COM0
0056  0227             // Syntax   : serin();
0057  0228             // Usage    : char := serin();
0058  0229             // Notes    : Receives a character from the Serial Port COM0. The transmission format is:
0059  0230             //          : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
0060  0231             //          : The default Baud Rate is 115,200 bits per second or 115,200 baud. The baud rate can be
0061  0232             //          : changed under program control by using the setbaud(...) function.
0062  0233             //          : Returns: -1 if no character is available
0063  0234             //          : Returns: -2 if a framing error or over-run has occurred (auto cleared)
0064  0235             //          : Returns: positive value 0 to 255 for a valid character received
0065  0236   
0066  0237             func putch("char"), 0;                          // write single char to current output device
0067  0238             // Syntax   : putch("char");
0068  0239             // Usage    : putch("A");
0069  0240             // Notes    : Transmits a single byte from the Serial Port COM0. The transmission format is:
0070  0241             //          : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
0071  0242             //          : The default Baud Rate is 115,200 bits per second or 115,200 baud. The baud rate can be
0072  0243             //          : changed under program control by using the setbaud(...) function.
0073  0244             //          : The arguments can be a variable, array element, expression or constant
0074  0245   
0075  0246             func serout("char"), 0;                         // write a byte to COM0
0076  0247             // Syntax   : serout1("char");
0077  0248             // Usage    : serout1(ch);
0078  0249             // Notes    : send character to COM1
0079  0250   
0080  0251             func setbaud("baudnum"), 0;                     // set baud rate of COM0
0081  0252             // Syntax   : setbaud(baud_number);
0082  0253             // Usage    : setbaud(BAUD_128000);        //Set baud rate to 128000bps
0083  0254             // Notes   : specifies the baud rate divisor value or pre-defined constant
0084  0255             //          : The arguments can be a variable, array element, expression or constant
0085  0256             //          : Baud Number Divisor
0086  0257             //          : BAUD_110    27271
0087  0258             //          : BAUD_300    9999
0088  0259             //          : BAUD_600    4999
0089  0260             //          : BAUD_1200   2499
0090  0261             //          : BAUD_2400   1249
0091  0262             //          : BAUD_4800   624
0092  0263             //          : BAUD_9600   312
0093  0264             //          : BAUD_14400  207
0094  0265             //          : BAUD_19200  155
0095  0266             //          : BAUD_31250  95
0096  0267             //          : BAUD_38400  77
0097  0268             //          : BAUD_56000  53
0098  0269             //          : BAUD_57600  51
0099  0270             //          : BAUD_115200 25
0100  0271             //          : BAUD_128000 22
0101  0272             //          : BAUD_256000 11
0102  0273             //          : BAUD_300000 10
0103  0274             //          : BAUD_375000 8
0104  0275             //          : BAUD_500000 6
0105  0276             //          : BAUD_600000 4
0106  0277             //          :
0107  0278             //          : The baud rate is calculated with the following formula:
0108  0279             //          : rate-divisor = (3000000 / baud ) - 1
0109  0280   
0110  0281             func to("device"), 1;                           // output device redirection
0111  0282             // Syntax   : to(outstream);
0112  0283             // Usage    : to(APPEND); putstr("TWO ");
0113  0284             // Notes    : outstream: A variable or constant specifying destination for putch, putstr, putnum and print functions.
0114  0285             //          :
0115  0286             //          : to() sends the printed output to destinations other than the screen. Normally, print just
0116  0287             //          : sends its output to the display in TEXT mode which is the default, however, the output from
0117  0288             //          : print can be sent to COM0, and MDA (media) 'streams'. The to(...) function can also stream
0118  0289             //          : to a memory array . Note that once the to(...) function has taken effect, the stream reverts
0119  0290             //          : back to the default stream which is TEXT as soon as putch, putstr, putnum or print has
0120  0291             //          : completed its action. The APPEND argument is used to send the printed output to the same
0121  0292             //          : place as the previous redirection. This is most useful for building string arrays, or adding
0122  0293             //          : sequential data to a media stream.
0123  0294             //          :
0124  0295             //          : Predefined Name   Constant    putch(), putstr(), putnum(), print() redirection
0125  0296             //          : APPEND            0x0000          Output is directed to the same stream that was previously assigned. Output is
0126  0297             //          :                                   appended to user array if previous redirection was to an array.
0127  0298             //          : COM0              0xFF04          Output is redirected to the COM (serial) port.
0128  0299             //          : TEXT              0xFF08          Output is directed to the screen (default).
0129  0300             //          : MDA               0xFF10          Output is directed to the SD or FLASH media.
0130  0301             //          : memory pointer    0x102<0x3FF     Output is redirect to the memory pointer argument.
0131  0302   
0132  0303             func pause("milliseconds"), 0;                  // blocking delay
0133  0304             // Syntax   : pause(milliseconds);
0134  0305             // Usage    : pause(1000);                      //pause for 1 second
0135  0306             // Notes    : Pause for a number of milli second.Maximum delay could be 65535 milli seconds
0136  0307   
0137  0308             func putnum("arg1","arg2"), 1;                  // print number to current output device
0138  0309             // Syntax   : putnum(format, value);
0139  0310             // Usage    : var := putnum(HEX, val);
0140  0311             // Notes    : prints a 16bit number in various formats to the current output stream, usually the display.
0141  0312             //          : Format: A constant that specifies the number format
0142  0313             //          : Value : The number to be printed
0143  0314             //          : (      DECIMAL   )    (   UNSIGNED DECIMAL )    (    HEX         )    (    BINARY          )
0144  0315             //          : DEC  DECZ  DECZB      UDEC  UDECZ  UDECZB       HEX  HEXZ  HEXZB      BIN  BINZ    BINZB
0145  0316             //          : DEC1 DEC1Z DEC1ZB     UDEC1 UDEC1Z UDEC1ZB      HEX1 HEX1Z HEX1ZB     BIN1  BIN1Z   BIN1ZB
0146  0317             //          : DEC2 DEC2Z DEC2ZB     UDEC2 UDEC2Z UDEC2ZB      HEX2 HEX2Z HEX1ZB     BIN2  BIN2Z   BIN2ZB
0147  0318             //          : DEC3 DEC3Z DEC3ZB     UDEC3 UDEC3Z UDEC3ZB      HEX3 HEX3Z HEX1ZB     BIN3  BIN3Z   BIN3ZB
0148  0319             //          : DEC4 DEC4Z DEC4ZB     UDEC4 UDEC4Z UDEC4ZB      HEX4 HEX4Z HEX1ZB     BIN4  BIN4Z   BIN4ZB
0149  0320             //          : DEC5 DEC5Z DEC5ZB     UDEC5 UDEC5Z UDEC5ZB                            BIN5  BIN5Z   BIN5ZB
0150  0321             //          :                                                                       BIN6  BIN6Z   BIN6ZB
0151  0322             //          :                                                                       BIN7  BIN7Z   BIN7ZB
0152  0323             //          :                                                                       BIN8  BIN8Z   BIN8ZB
0153  0324             //          :                                                                       BIN9  BIN9Z   BIN9ZB
0154  0325             //          :                                                                       BIN10 BIN10Z  BIN10ZB
0155  0326             //          :                                                                       BIN11 BIN11Z  BIN11ZB
0156  0327             //          :                                                                       BIN12 BIN12Z  BIN12ZB
0157  0328             //          :                                                                       BIN13 BIN13Z  BIN13ZB
0158  0329             //          :                                                                       BIN14 BIN14Z  BIN14ZB
0159  0330             //          :                                                                       BIN15 BIN15Z  BIN15ZB
0160  0331             //          :                                                                       BIN16 BIN16Z  BIN16ZB
0161  0332             //          :
0162  0333             //          : field: Returns the the default width of the numeric field (digit count), usually ignored.
0163  0334             //          :============================================================================
0164  0335             //          : number formatting bits
0165  0336             //          :============================================================================
0166  0337             //          : bit 15 14 13 12 11 10 9  8  7  6  5  4  3  2  1  0
0167  0338             //          :     |  |  |  |   \___ ___/  |  \  /  \_____ _____/
0168  0339             //          :     |  |  |  |       V      |   V          V
0169  0340             //          :     |  |  |  |       |      |   |          |
0170  0341             //          :     |  |  |  |  digit count |   |          |
0171  0342             //          :     |  |  |  |  (nb 0 = 16) |   |          |____BASE (usually 2,10 or 16)
0172  0343             //          :     |  |  |  |              |   |
0173  0344             //          :     |  |  |  |              |   |___reserved (not used on Goldelox)
0174  0345             //          :     |  |  |  |              |
0175  0346             //          :     |  |  |  |              |____ string indicatior
0176  0347             //          :     |  |  |  |                      0x80 = [STR]
0177  0348             //          :     |  |  |  |                      0x81 = [CHR]
0178  0349             //          :     |  |  |  |______
0179  0350             //          :     |  |  |           1 = leading zeros included
0180  0351             //          :     |  |  |           0 = leading zeros suppressed
0181  0352             //          :     |  |  |
0182  0353             //          :     |  |  |_______
0183  0354             //          :     |  |           1 = leading zero blanking
0184  0355             //          :     |  |
0185  0356             //          :     |  |_____ sign bit (0 = signed, 1 = unsigned)
0186  0357             //          :     |
0187  0358             //          :     |______ 1 = space before unsigned number
0188  0359   
0189  0360   
0190  0361             func translate("arg1","arg2","arg3","arg4"), 1; // list translator (internal use only)
0191  0362             // Syntax   :  This function is used only by the compiler
0192  0363             // Usage    :   Lookup8 and Lookup16
0193  0364             // Notes    : Reserved for use by compiler only, no use to the programmer
0194  0365   
0195  0366             func putstr("string"), 1;            // print string to current output device
0196  0367             // Syntax   : putstr(pointer);
0197  0368             // Usage    : putstr("HELLO\n");
0198  0369             // Notes    : putstr prints a string to the current output stream, usually the display. The argument can be
0199  0370             //          : a string constant, a pointer to a string, a pointer to an array, or a pointer to a data statement.
0200  0371             //          : The output of putstr can be redirected to the communications port, the media, or memory
0201  0372             //          : using the to(...); function.
0202  0373             //          : A string constant is automatically terminated with a zero.
0203  0374             //          : A string in a data statement is not automatically terminated with a zero.
0204  0375             //          : All variables in 4DGL are 16bit, if an array is used for holding 8 bit characters, each array
0205  0376             //          : element packs 1 or 2 characters.
0206  0377             //          :
0207  0378             //          : Returns the pointer to the item that was printed.
0208  0379   
0209  0380             //==============================================//
0210  0381             // Memory Access Function Prototypes            //
0211  0382             //==============================================//
0212  0383   
0213  0384             func peekB("address"), 1;                       // read a byte from system or user memory
0214  0385             // Syntax   : peekB(address);
0215  0386             // Usage    : myvar := peekB(GFX_XMAX);
0216  0387             // Notes    : This function returns the 8 bit value that is stored at address.
0217  0388             //          : The peekB(..) and pokeB(..) functions are usually only used with internal system byte
0218  0389             //          : registers using the pre-defined constants. If peekB(..) or pokeB(..) are used to access other
0219  0390             //          : locations, the address must be doubled to get the correct pointer address.
0220  0391             //          :
0221  0392             //          : Address: The address of a memory byte. The address is usually a pre-defined system
0222  0393             //          : register address constant, The arguments can be a variable, array element, expression or constant.
0223  0394             //          : Return: The 8 bit value stored at address.
0224  0395   
0225  0396             func peekW("address"), 1;                       // read a word from system or user memory
0226  0397             // Syntax   : peekW(address);
0227  0398             // Usage    : myvar := peekW(SYSTEM_TIMER_LO);
0228  0399             // Notes    : This function returns the 16 bit value that is stored at address.
0229  0400             //          : The address of a memory word. The address is usually a pre-defined system register address constant,
0230  0401             //          : The arguments can be a variable, array element, expression or constant.
0231  0402   
0232  0403             func pokeB("address", "bytevalue"), 0;          // write a byte to system or user memory
0233  0404             // Syntax   : pokeB(address, byte_value);
0234  0405             // Usage    : pokeB(CLIP_TOP, 10);
0235  0406             // Notes    : This function writes a 8 bit value to a location specified by address.
0236  0407             //          : The peekB(..) and pokeB(..) functions are usually only used with internal system byte registers using the
0237  0408             //          : pre-defined constants. If peekB(..) or pokeB(..) are used to access other locations, the address must be
0238  0409             //          : doubled to get the correct pointer address.
0239  0410             //          :
0240  0411             //          : address: Address of a memory byte. It is usually a pre-defined system register address constant
0241  0412             //          : byte_value: The lower 8 bits of byte_value will be stored at address.
0242  0413             //          : Returns TRUE if poke address was a legal address (usually ignored).
0243  0414   
0244  0415             func pokeW("address", "wordvalue"), 0;          // write a word to system or user memory
0245  0416             // Syntax   : pokeW(address, word_value);
0246  0417             // Usage    : pokeW(TIMER2, 5000);
0247  0418             // Notes    : This function writes a 16 bit value to a location specified by address.
0248  0419             //          :
0249  0420             //          : Address: Address of a memory word. The address is usually a pre-defined system register  address constant
0250  0421             //          : word_value: The 16 bit word_value will be stored at address.
0251  0422             //          : The arguments can be a variable, array element, expression or constant.
0252  0423             //          :
0253  0424             //          : Returns TRUE if poke address was a legal address (usually ignored).
0254  0425   
0255  0426             //==============================================//
0256  0427             // bit manipulators                             //
0257  0428             //==============================================//
0258  0429   
0259  0430             func bits_Set("address","mask"), 0;             // set required bit(s) in memory (16bit operation)
0260  0431             // Syntax   : bits_Set(address, mask);
0261  0432             // Usage    : bits_Set(myval, 0xC0);
0262  0433             // Notes    : This function sets the required bits at address by 'ORing' the mask with the value stored at address.
0263  0434             //          : The bits_Set, bits_Clear, bits_Flip and bits_Test functions can only be used for user memory and will
0264  0435             //          : not work with system register variables
0265  0436             //          :
0266  0437             //          : address :     The address of a user memory location.
0267  0438             //          : mask    :    The 16 bit mask containing bits to be set.
0268  0439             //          : The arguments can be a variable, array element, expression or constant.
0269  0440   
0270  0441             func bits_Clear("address","mask"), 0;           // clear required bit(s) in memory (16bit operation)
0271  0442             // Syntax   : bits_Clear(address, mask);
0272  0443             // Usage    : bits_Clear(myval, 0x3C00);
0273  0444             // Notes    : This function clears the required bits at address by 'ANDing' the inverted mask with the value stored at
0274  0445             //          : address.
0275  0446             //          : The bits_Set, bits_Clear, bits_Flip and bits_Test functions can only be used for user memory and will not
0276  0447             //          : work with system register variables.
0277  0448             //          :
0278  0449             //          : address:     The address of a user memory location.
0279  0450             //          : mask   :     The 16 bit mask containing bits to be cleared.
0280  0451             //          : The arguments can be a variable, array element, expression or constant.
0281  0452   
0282  0453             func bits_Flip("address","mask"), 0;            // invert required bit(s) in memory (16bit operation)
0283  0454             // Syntax   : bits_Flip(address, mask);
0284  0455             // Usage    : bits_Flip(myval, 0x8802);
0285  0456             // Notes    : This function flips the required bits at address by 'XORing' the mask with the value stored at address.
0286  0457             //          : The bits_Set, bits_Clear, bits_Flip and bits_Test functions can only be used for user memory and will not
0287  0458             //          : work with system register variables.
0288  0459             //          :
0289  0460             //          : address: The address of a user memory location.
0290  0461             //          : mask   : The 16 bit mask containing bits to be flipped.
0291  0462             //          : The arguments can be a variable, array element, expression or constant.
0292  0463   
0293  0464             func bits_Test("address","mask"), 1;            // test required bit(s) in memory (16bit operation)
0294  0465   
0295  0466             //==============================================//
0296  0467             // Math Functions                               //
0297  0468             //==============================================//
0298  0469   
0299  0470             func ABS("value"), 1;                           // return a positive number
0300  0471             // Syntax   : ABS(value);
0301  0472             // Usage    : var := ABS(arg);
0302  0473             // Notes    : Returns the absolute value of an argument
0303  0474   
0304  0475             func MIN("value1", "value2"), 1;                // return the smaller of 2 numbers
0305  0476             // Syntax   : MIN(value1, value2);
0306  0477             // Usage    : var := MIN(arg1, arg2);
0307  0478             // Notes    : Returns the minimum of 2 arguments
0308  0479   
0309  0480             func MAX("value1", "value2"), 1;                // return the larger of 2 numbers
0310  0481             // Syntax   : MAX(value1, value2);
0311  0482             // Usage    : var := MAX(arg1, arg2);
0312  0483             // Notes    : Returns the maximum of 2 arguments
0313  0484   
0314  0485             func SWAP("*var", "*var"), 0;                   // swap 2 variables, arguments must point to variables
0315  0486             // Syntax   : SWAP(var1, var2);
0316  0487             // Usage    : SWAP(var1, var2);
0317  0488             // Notes    : Swaps the contents of 2 variables or memory locations
0318  0489   
0319  0490             func SIN("angle"), 1;                           // return SIN of angle
0320  0491             // Syntax   : SIN(angle);
0321  0492             // Usage    : var := SIN(arg);
0322  0493             // Notes    : Returns the sine in radians of an argument in degrees
0323  0494             //          : the returned value range is from 127 to -127. The real
0324  0495             //          : cosine values vary from 1.0 to -1.0 so appropriate
0325  0496             //          : scaling must be done in user code.
0326  0497   
0327  0498             func COS("angle"), 1;                           // return COS of angle
0328  0499             // Syntax   : COS(angle);
0329  0500             // Usage    : var := COS(arg);
0330  0501             // Notes    : Returns the cosine in radians of an argument in degrees
0331  0502             //          : the returned value range is from 127 to -127. The real
0332  0503             //          : cosine values vary from 1.0 to -1.0 so appropriate
0333  0504             //          : scaling must be done in user code.
0334  0505   
0335  0506             func RAND(), 1;                                 // return a pseudo random number
0336  0507             // Syntax   : RAND();
0337  0508             // Usage    : var := RAND();
0338  0509             // Notes    : Returns a random number between 0 and 0xFFFF.
0339  0510             //          : The random number generator must first be seeded
0340  0511             //          : by using the SEED(number) function.
0341  0512   
0342  0513             func SEED("number"), 0;                         // re-seed the pseudo random number generator
0343  0514             // Syntax   : SEED(number);
0344  0515             // Usage    : SEED(arg);
0345  0516             // Notes    : Seeds the random number generator.
0346  0517   
0347  0518             func OVF(), 1;                                  // returns upper 16bits of 32bit results
0348  0519             // Syntax   : OVF();
0349  0520             // Usage    : var:= OVF();
0350  0521             // Notes    :
0351  0522   
0352  0523             func SQRT("number"), 1;                         // return square root of a number
0353  0524             // Syntax   : SQRT(number);
0354  0525             // Usage    : var := SQRT(number);
0355  0526             // Notes    :
0356  0527   
0357  0528             //==============================================//
0358  0529             // Text Control Function                        //
0359  0530             //==============================================//
0360  0531   
0361  0532             func txt_MoveCursor("line", "column"), 0;       // move to required text position (font size related)
0362  0533             // Syntax   : txt_SetCursor(line, column);
0363  0534             // Usage    : txt_SetCursor(arg1, arg2);
0364  0535             // Notes    : Moves the text Cursor to a new screen position set by
0365  0536             //          : line,column parameters.
0366  0537   
0367  0538             func txt_Set("mode", "value"), 0;               // various functions, (see constants below)
0368  0539             // Syntax   : txt_Set(mode, value);
0369  0540             // Usage    : txt_Set(arg1, arg2);
0370  0541             // Notes    : Sets various text related parameters used by other functions
0371  0542             //          :
0372  0543             //          : mode = TEXT_COLOUR (mode 0)
0373  0544             //          : txt_Set(TEXT_COLOUR, value);
0374  0545             //          : value = 0 to 0xFFFF, Black to White
0375  0546             //          : Sets the Text colour for the display
0376  0547             //          : Default = GREEN.
0377  0548             //          :
0378  0549             //          : mode = TEXT_HIGHLIGHT (mode 1)
0379  0550             //          : txt_Set(TEXT_HIGHLIGHT, value);
0380  0551             //          : value = 0 to 0xFFFF, Black to White
0381  0552             //          : Sets the Text background colour for the display. Effective
0382  0553             //          : when text mode is Opaque.
0383  0554             //          : Default = BLACK.
0384  0555             //          :
0385  0556             //          : mode = FONT_ID (mode 2)
0386  0557             //          : txt_Set(FONT_ID, value);
0387  0558             //          : value = FONT1, FONT2 or FONT3 for internal fonts
0388  0559             //          : else this value is the name of a font included
0389  0560             //          : in a users program in a data statement.
0390  0561             //          : Default = FONT SIZE 3.
0391  0562             //          :
0392  0563             //          : mode = TEXT_WIDTH  (mode 3)
0393  0564             //          : txt_Set(TEXT_WIDTH, value);
0394  0565             //          : value = 1 to 16
0395  0566             //          : Sets the Text Width multiplier
0396  0567             //          : text will be printed magnified horizontally
0397  0568             //          : by this factor, Default = 1.
0398  0569             //          :
0399  0570             //          : mode = TEXT_HEIGHT  (mode 4)
0400  0571             //          : txt_Set(TEXT_HEIGHT, value);
0401  0572             //          : value = 1 to 16
0402  0573             //          : Sets the Text Height multiplier
0403  0574             //          : text will be printed magnified vertically
0404  0575             //          : by this factor, Default = 1.
0405  0576             //          :
0406  0577             //          : mode = TEXT_XGAP  (mode 5)
0407  0578             //          : txt_Set(TEXT_XGAP, value);
0408  0579             //          : value = 1 to 32
0409  0580             //          : Sets the horizontal gap between characters
0410  0581             //          : The gap is in pixel units, Default = 0
0411  0582             //          :
0412  0583             //          : mode = TEXT_YGAP  (mode 6)
0413  0584             //          : txt_Set(TEXT_YGAP, value);
0414  0585             //          : value = 1 to 32
0415  0586             //          : Sets the vertical gap below characters
0416  0587             //          : The gap is in pixel units, Default = 0
0417  0588             //          :
0418  0589             //          : mode = TEXT_PRINTDELAY  (mode 7) DEPRECATED
0419  0590             //          : txt_Set(TEXT_PRINTDELAY, value);
0420  0591             //          : value = 0 to 255
0421  0592             //          : Sets the delay time (in ms) during character
0422  0593             //          : printing to give a 'teletype' like effect.
0423  0594             //          : Often used to attract attention to a string
0424  0595             //          : being printed which can often be missed if
0425  0596             //          : just suddenly appearing or changing.
0426  0597             //          : Default = 0 ms.
0427  0598             //          :
0428  0599             //          : mode = TEXT_OPACITY (mode 8)
0429  0600             //          : txt_Set(TEXT_OPACITY, value);
0430  0601             //          : value = TRANSPARENT (0) = Text Trasparent
0431  0602             //          : value = OPAQUE (1) = Text Opaque
0432  0603             //          : Sets the Opacity/Transparency of the text
0433  0604             //          : Default = 0 or TRANSPARENT
0434  0605             //          :
0435  0606             //          : mode = TEXT_BOLD (mode 9)
0436  0607             //          : txt_Set(TEXT_BOLD, value);
0437  0608             //          : value = dont care
0438  0609             //          : Sets Bold Text mode for the next string or char
0439  0610             //          : The feature automatically resets after printing
0440  0611             //          : using putstr or print has completed
0441  0612             //          :
0442  0613             //          : mode = TEXT_ITALIC (mode 10)
0443  0614             //          : txt_Set(TEXT_ITALIC, value);
0444  0615             //          : value = dont care
0445  0616             //          : Sets Italic Text mode for the next string or char
0446  0617             //          : The feature automatically resets after printing
0447  0618             //          : using putstr or print has completed
0448  0619   
0449  0620             //          : mode = TEXT_INVERSE (mode 11)
0450  0621             //          : txt_Set(TEXT_INVERSE, value);
0451  0622             //          : value = dont care
0452  0623             //          : Sets Inverse Text mode for the next string or char
0453  0624             //          : The feature automatically resets after printing
0454  0625             //          : using putstr or print has completed
0455  0626             //          :
0456  0627             //          : mode = TEXT_UNDERLINED (mode 12)
0457  0628             //          : txt_Set(TEXT_UNDERLINED, value);
0458  0629             //          : value = dont care
0459  0630             //          : Sets Underlined Text mode for the next string or char
0460  0631             //          : The feature automatically resets after printing
0461  0632             //          : using putstr or print has completed
0462  0633             //          :
0463  0634             //          : mode = TEXT_ATTRIBUTES (mode 13)
0464  0635             //          : txt_Set(TEXT_ATTRIBUTES, value);
0465  0636             //          : value = bits are defined as:
0466  0637             //          :  BOLD        16          // TEXT_ATTRIBUTES bold text (auto reset)
0467  0638             //          :  ITALIC      32          // TEXT_ATTRIBUTES italic text (auto reset)
0468  0639             //          :  INVERSE     64          // TEXT_ATTRIBUTES inverse text (auto reset)
0469  0640             //          :  UNDERLINED  128         // TEXT_ATTRIBUTES underlined text (auto reset)
0470  0641             //          : Allows a combination of text attributes to be defined together
0471  0642             //          : by 'or'ing the bits together.
0472  0643             //          : Example: txt_Set(TEXT_ATTRIBUTES, BOLD | INVERSE); // bold + inverse
0473  0644             //          : The feature automatically resets after printing
0474  0645             //          : using putstr or print has completed.
0475  0646             //          : Bits 0-3 and 8-15 are reserved for future attributes.
0476  0647   
0477  0648             //==============================================//
0478  0649             // Hardware Function Prototypes                 //
0479  0650             //==============================================//
0480  0651             //        OUTPUT      0
0481  0652             //        INPUT       1
0482  0653             //        ANALOGUE_8  2
0483  0654             //        ANALOGUE_10 3
0484  0655             //        ONEWIRE     4
0485  0656             //        SOUND        5
0486  0657   
0487  0658             func pin_Set("mode", "pin"), 0;                 // set pin to required mode
0488  0659             // Syntax   : pin_Set(mode, pin);
0489  0660             // Usage    : pin_Set(arg1, arg2);
0490  0661             // Notes    : Sets the appropriate pins to Inputs or Outputs
0491  0662             //          :
0492  0663   
0493  0664             func pin_HI("pin"), 0;                          // set pin to logic '1'
0494  0665             // Syntax   : pin_HI(pin);
0495  0666             // Usage    : pin_HI(PIN_0);
0496  0667             //          : pin = PIN_1 : set PIN_1 (a.k.a. RUN pin) to output
0497  0668             //          : pin = PIN_2 : set PIN_2 pin to output (not available on GMD1 modules)
0498  0669             // Notes    : Outputs a logic "High" (3.3V) on the appropriate
0499  0670             //          : pin that was previously selected as an Output.
0500  0671   
0501  0672             func pin_LO("pin"), 0;                          // set pin to logic '0'
0502  0673             // Syntax   : pin_LO(pin);
0503  0674             // Usage    : pin_LO(PIN_0);
0504  0675             // Notes    : Outputs a logic "Low" (0V) on the appropriate
0505  0676             //          : pin = PIN_1 : set PIN_1 (a.k.a. RUN pin) to output
0506  0677             //          : pin = PIN_2 : set PIN_2 pin to output (not available on GMD1 modules)
0507  0678             //          : pin that was previously  selected as an Output.
0508  0679   
0509  0680             func pin_Read("pin"), 1;                        // read pin, logic or analogue
0510  0681             // Syntax   : pin_Read(PIN_0);
0511  0682             // Usage    : arg1 := pin_Read(arg2);
0512  0683             // Notes    : Reads the logic state or analogue value of the appropriate
0513  0684             //          : pin that was previously selected as an Input or *Analogue.
0514  0685             //          : pin = 0 : Read the state of the RUN pin
0515  0686             //          : Returns a 0 (logic low) or 1 (logic high) or n Analogue.
0516  0687             //          : *NB: Analogue is only available on PIN_1
0517  0688   
0518  0689             func OW_Reset(), 1;                             // issue 1wire reset command
0519  0690             // Syntax   : OW_Reset();
0520  0691             // Usage    : OW_Reset();
0521  0692             // Notes    : Resets  ONEWIRE device
0522  0693             //          : Returns the status, 0 = ACK.
0523  0694             //          :
0524  0695   
0525  0696             func OW_Read(), 1;                              // read data from 1wire bus
0526  0697             // Syntax   : OW_Read();
0527  0698             // Usage    : arg1 := OW_Read();
0528  0699             // Notes    : Reads value of the ONEWIRE pin
0529  0700             //          : that was previously selected for ONEWIRE comms.
0530  0701             //          :
0531  0702             //          : pin = 0 : the next byte from the ONEWIRE bus
0532  0703   
0533  0704             func OW_Read9(), 1;                             // read data from 1wire bus, 9bit mode
0534  0705             // Syntax   : OW_Read9();
0535  0706             // Usage    : OW_Read9();
0536  0707             // Notes    : Reads 9 bit value of the appropriate ONEWIRE pin
0537  0708             //          : that was previously selected for ONEWIRE comms.
0538  0709             //          :
0539  0710             //          : read the 9 bits from the ONEWIRE bus
0540  0711   
0541  0712             func OW_Write("value"), 0;                      // write value to 1wire device
0542  0713             // Syntax   : OW_Write(arg);
0543  0714             // Usage    : OW_Write(arg);
0544  0715             // Notes    : Sends ONEWIRE data on the appropriate
0545  0716             //          : pin that was previously  selected as ONEWIRE comms.
0546  0717             //          :
0547  0718             //          : write arg to the ONEWIRE bus
0548  0719   
0549  0720             func beep("pitch","duration"), 0;               // generate a note on specified port pin
0550  0721             // Syntax   : beep(note, duration);
0551  0722             // Usage    : Beep(20, 50);
0552  0723             // Notes    : Generates a beep for a certain period of time
0553  0724             //          : note    : A value (usually a constant) specifying the frequency of the note.
0554  0725             //          : duration: specifies the time in milliseconds that the note will be played for.
0555  0726             //          : The arguments can be a variable, array element, expression or constant
0556  0727   
0557  0728             func joystick(), 1;                             // read the joystick value
0558  0729             // Syntax   : Joystick();
0559  0730             // Usage    : var := Joystick();
0560  0731             // Notes    : Returned values are:-
0561  0732             //          :    RELEASED 0
0562  0733             //          :    UP       1
0563  0734             //          :    LEFT     2
0564  0735             //          :    DOWN     3
0565  0736             //          :    RIGHT    4
0566  0737             //          :    FIRE     5
0567  0738   
0568  0739             //==============================================//
0569  0740             // Graphics Mode Function Prototypes            //
0570  0741             //==============================================//
0571  0742   
0572  0743             func gfx_Set("mode", "value"), 0;               // set various graphics functions
0573  0744             // Syntax   : gfx_Set(mode, value);
0574  0745             // Usage    : gfx_Set(arg1, arg2);
0575  0746             // Notes    : Sets various graphics parameters used by other functions
0576  0747             //          :
0577  0748             //          : mode = 0 : PenSize
0578  0749             //          : gfx_Set(PEN_SIZE, value);
0579  0750             //          : value = SOLID   : Object Solid
0580  0751             //          : value = OUTLINE : Object Outline
0581  0752             //          : Sets the size of the Pen used by most graphics objects
0582  0753             //          :
0583  0754             //          : mode = 1 : Background Colour
0584  0755             //          : gfx_Set(1, value);
0585  0756             //          : value = 0 to 0xFFFF, Black to White
0586  0757             //          : Sets the Background colour of the screen for gfx_Cls();
0587  0758             //          :
0588  0759             //          : mode = 2 : Object Colour
0589  0760             //          : gfx_Set(OBJECT_COLOUR, value);
0590  0761             //          : value = 0 to 0xFFFF, Black to White
0591  0762             //          : Sets the Object colour used in various functions
0592  0763             //          : LineTo(,,); LineRel(,,); BoxTo(,,); Dot(); etc.
0593  0764             //          :
0594  0765             //          : mode = 3 : Clipping
0595  0766             //          : gfx_Set(CLIPPING, value);
0596  0767             //          : value = OFF : Clipping disabled
0597  0768             //          : value = ON  : Clipping enabled
0598  0769             //          : Enables/Disables the Clipping feature
0599  0770             //          :
0600  0771             //          : mode = 7 : Set required screen behaviour
0601  0772             //          : gfx_Set(SCREEN_MODE, value);
0602  0773             //          : value = LANDSCAPE         1
0603  0774             //          : value = LANDSCAPE_R     2
0604  0775             //          : value = PORTRAIT         3
0605  0776             //          : value = PORTRAIT_R     4
0606  0777             //          :
0607  0778             //          : mode = 8 : Outline Colour
0608  0779             //          : gfx_Set(OUTLINE_COLOUR, value);
0609  0780             //          : value = 1 to 0xFFFF, OFF to White
0610  0781             //          : Sets the Rectangle or Circle objects outline colour
0611  0782             //          : If outline colour, is 0, OUTLINE_COLOUR feature is disabled
0612  0783             //          : gfx_Set(OUTLINE_COLOUR, OFF); may be used for this
0613  0784             //          :
0614  0785             //          : mode = 9 : Contrast
0615  0786             //          : gfx_Set(CONTRAST, value);
0616  0787             //          : value = 1 to 16, 1=lowest, 16=highest contrast
0617  0788             //          : value = 0 puts display into low power mode.
0618  0789             //          : Sets the contrast
0619  0790             //          : gfx_Set(CONTRAST, OFF); may be used for this
0620  0791   
0621  0792             func gfx_Cls(), 0;                    // clear the screen
0622  0793             // Syntax   : gfx_Cls();
0623  0794             // Usage    : gfx_Cls();
0624  0795             // Notes    : Clears the screen with current background colour
0625  0796   
0626  0797             func gfx_MoveTo("x", "y"), 0;                   // set glb_X1 and glb_Y1 to required co-ordinate
0627  0798             // Syntax   : gfx_MoveTo(x, y);
0628  0799             // Usage    : gfx_MoveTo(arg1, arg2);
0629  0800             // Notes    : Moves the origin to a new x,y position
0630  0801   
0631  0802             func gfx_MoveRel("x", "y"), 0;                  // set glb_X1 and glb_Y1 to new relative offset
0632  0803             // Syntax   : gfx_MoveTo(x, y);
0633  0804             // Usage    : gfx_MoveTo(arg1, arg2);
0634  0805             // Notes    : Moves the origin relative to  x,y and sets a new position
0635  0806   
0636  0807             func gfx_LineTo("x1", "y1"), 0;                 // draw line from current origin to new point
0637  0808             // Syntax   : gfx_LineTo(x1, y1);
0638  0809             // Usage    : gfx_LineTo(arg1, arg2);
0639  0810             // Notes    : Draws a Line from the origin x,y to x1,y1.
0640  0811             //          : The new origin is then set to x1, y1. Line colour needs
0641  0812             //          : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
0642  0813   
0643  0814             func gfx_LineRel("x1", "y1"), 0;                // draw line from current origin to new relative offset
0644  0815             // Syntax   : gfx_LineRel(x1, y1);
0645  0816             // Usage    : gfx_LineRel(arg1, arg2);
0646  0817             // Notes    : Draws a Line from the origin x,y to x1,y1.
0647  0818             //          : Unlike gfx_MoveTo() the origin is not updated with x1, y1. Line colour needs
0648  0819             //          : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
0649  0820   
0650  0821             func gfx_Line("x1", "y1", "x2", "y2", "colr"), 0;  // draw line, can be patterned
0651  0822             // Syntax   : gfx_Line(x1, y1, x2, y2, colr);
0652  0823             // Usage    : gfx_Line(arg1, arg2, arg3, arg4, arg5);
0653  0824             // Notes    : Plots a coloured Line from x1,y1 to x2,y2 on the screen
0654  0825   
0655  0826             func gfx_Hline("y", "x1", "x2", "colr"), 1;     // draw Hline, can be patterned
0656  0827             // Syntax   : gfx_Hline(y, x1, x2, colr);
0657  0828             // Usage    : var := gfx_Hline(arg1, arg2, arg3, arg4);
0658  0829             // Notes    : Plots a coloured Horizontal Line y pixels away from origin
0659  0830             //          : starting from x1 to x2
0660  0831             //          : Returns number of pixels plotted
0661  0832   
0662  0833             func gfx_Vline("x", "y1", "y2", "colr"), 1;    // draw Vline, can be patterned
0663  0834             // Syntax   : gfx_Vline(x, y1, y2, colr);
0664  0835             // Usage    : var := gfx_Vline(arg1, arg2, arg3, arg4);
0665  0836             // Notes    : Plots a coloured Vertical Line x pixels away from origin
0666  0837             //          : starting from y1 to y2
0667  0838             //          : Returns number of pixels plotted
0668  0839   
0669  0840             func gfx_Rectangle("x1" ,"y1", "x2", "y2", "colr"), 0;  // draw open rectangle,line can be patterned
0670  0841             // Syntax   : gfx_Rectangle(x1, y1, x2, y2, colr);
0671  0842             // Usage    : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
0672  0843             // Notes    : Plots a coloured Outline Rectangle from top corner (x1,y1) to
0673  0844             //          : bottom corner (x2,y2) on the screen.
0674  0845   
0675  0846             func gfx_RectangleFilled("x1","y1","x2","y2","colr"), 0;  // draw filled rectangle
0676  0847             // Syntax   : gfx_Rectangle(x1, y1, x2, y2, colr);
0677  0848             // Usage    : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
0678  0849             // Notes    : Plots a coloured Solid Rectangle from top corner (x1,y1) to
0679  0850             //          : bottom corner (x2,y2) on the screen.
0680  0851   
0681  0852             func gfx_Circle("x", "y", "rad", "colr"), 0;  // draw open circle
0682  0853             // Syntax   : gfx_Circle(x, y, rad, colr);
0683  0854             // Usage    : gfx_Circle(arg1, arg2, arg3, arg4);
0684  0855             // Notes    : Plots a coloured outline Circle on the screen at centre x,y with radius = rad
0685  0856   
0686  0857             func gfx_CircleFilled("x", "y", "rad", "colr"), 0;        // draw filled circle
0687  0858             // Syntax   : gfx_CircleFilled(x, y, rad, colr);
0688  0859             // Usage    : gfx_CircleFilled(arg1, arg2, arg3, arg4);
0689  0860             // Notes    : Plots a coloured Solid Circle on the screen at centre x,y with radius = rad
0690  0861   
0691  0862             func gfx_PutPixel("x", "y", "colr"), 0;      // set point at x y
0692  0863             // Syntax   : gfx_PutPixel(x, y, colr);
0693  0864             // Usage    : gfx_PutPixel(arg1, arg2, arg3);
0694  0865             // Notes    : Plots a coloured pixel on the screen at x,y location
0695  0866   
0696  0867             func gfx_GetPixel("x", "y"), 1;             // read colour at point x y
0697  0868             // Syntax   : gfx_GetPixel(x, y);
0698  0869             // Usage    : var := gfx_GetPixel(arg1, arg2);
0699  0870             // Notes    : Reads and returns the colour value of a pixel at location x,y
0700  0871   
0701  0872             func gfx_Triangle("x1","y1","x2","y2","x3","y3","colr"), 0; // draw an open triangle
0702  0873             // Syntax   : gfx_Triangle(x1, y1, x2, y2, x3, y3, colr);
0703  0874             // Usage    : gfx_Triangle(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
0704  0875             // Notes    : Plots a coloured outline Triangle from between 3 vertices: x1,y1 x2,y2 x3,y3
0705  0876             //          : Vertices must be specified in an anti-clockwise fashion
0706  0877   
0707  0878             func gfx_OrbitInit("&x_orb", "&y_orb"), 0;  // set result holders for orbit command
0708  0879             // Syntax   : gfx_OrbitInit(&x_orb, &y_orb);
0709  0880             // Usage    : gfx_OrbitInit(&arg1, &arg2);
0710  0881             // Notes    : Sets up the Orbit function parameters.
0711  0882             //          : &x_orb, &y_orb: calcualted Orbit coordiantes. These are pointers to local
0712  0883             //          : variables that get updated after calling gfx_Orbit(,,) function.
0713  0884             //          : The coordiantaes are calculated relative to the origin
0714  0885             //          : obtained by using the gfx_MoveTo(x, y) function.
0715  0886   
0716  0887             func gfx_Orbit("angle", "distance"), 0;     // calculate point at angle, distance
0717  0888             // Syntax   : gfx_Orbit(angle, distance);
0718  0889             // Usage    : gfx_Orbit(arg1, arg2);
0719  0890             // Notes    : The Orbit function calcualtes the x, y coordinates of a distant point whose
0720  0891             //          : only known parameters are the angle and the distance from the current origin.
0721  0892   
0722  0893             func gfx_Polyline("n", "&vx", "&vy", "colr"), 0;  // draw a polyline from a table of points
0723  0894             // Syntax   : gfx_Polyline(n, &vx, &vy, colr);
0724  0895             // Usage    : gfx_Polyline(arg1, x[array], y[array], arg2);
0725  0896             // Notes    : This function is very similar to the Polygon function
0726  0897             //          : with the exception of the 1st and the last vertices not joined.
0727  0898   
0728  0899             func gfx_Polygon("n", "&vx", "&vy", "colr"), 0;   // draw a polygon from a table of points
0729  0900             // Syntax   : gfx_Polygon(n, &vx, &vy, colr);
0730  0901             // Usage    : gfx_Polygon(arg1, x[array], y[array], arg2);
0731  0902             // Notes    : Plots a coloured Polygon between specified vertices: x1,y1 x2,y2 .. xn,yn
0732  0903             //          : Vertices must be minimum of 3 and can be specified in any fashion
0733  0904   
0734  0905             func gfx_Dot(), 0;                              // set point at glb_X glb_Y, default colour
0735  0906             // Syntax   : gfx_Dot();
0736  0907             // Usage    : gfx_Dot();
0737  0908             // Notes    : Places a coloured dot at the origin
0738  0909   
0739  0910             func gfx_Bullet("r"), 0;                        // draw circle at glb_X glb_Y, default colour
0740  0911             // Syntax   : gfx_Dot(r);
0741  0912             // Usage    : gfx_Dot(radius);
0742  0913             // Notes    : Places a coloured circle at the origin with radius r
0743  0914             //          : colour needs to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
0744  0915             //          : and the PenSize setting determines if circle is solid or outline.
0745  0916   
0746  0917             func gfx_IncX(), 1;                            // increment global origin glb_X, returning new value
0747  0918             // Syntax   : gfx_IncX();
0748  0919             // Usage    : var := gfx_IncX();
0749  0920             // Notes    : Increments the x coordinate of the origin
0750  0921             // Notes    : Returns new value
0751  0922   
0752  0923             func gfx_IncY(), 1;                            // increment global origin glb_Y, returning new value
0753  0924             // Syntax   : gfx_IncY();
0754  0925             // Usage    : var := gfx_IncY();
0755  0926             // Notes    : Increments the y coordinate of the origin
0756  0927             // Notes    : Returns new value
0757  0928   
0758  0929             func gfx_BoxTo("x1", "y1"), 0;                 // draw rectangle from current origin to x1 y1
0759  0930             // Syntax   : gfx_BoxTo(x1, y1);
0760  0931             // Usage    : gfx_BoxTo(arg1, arg2);
0761  0932             // Notes    : Draws a Rectangle from the origin x,y to x1,y1.
0762  0933             //          : The new origin is then set to x1,y1. Rectangle colour needs
0763  0934             //          : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
0764  0935             //          : and the PenSize setting determines if Box is solid or outline.
0765  0936   
0766  0937             func gfx_ClipWindow("x1" ,"y1", "x2", "y2"), 0;  // set the cipping area
0767  0938             // Syntax   : gfx_ClipWindow(x1, y1, x2, y2);
0768  0939             // Usage    : gfx_ClipWindow(arg1, arg2, arg3, arg4);
0769  0940             // Notes    : Specifies a clipping window region on the screen such that any objects
0770  0941             //          : and text placed onto the screen will be clipped and displayed only
0771  0942             //          : within that region. For the clipping window to take effect, "Clipping"
0772  0943             //          : must be enabled seperately using the gfx_Set(CLIPPING, ON) function.
0773  0944   
0774  0945             func gfx_ChangeColour("oldcolr", "newcolr"), 0;  // change pixel colour in clipping area
0775  0946             // Syntax   : gfx_ChangeColour(oldcolr, newcolr);
0776  0947             // Usage    : gfx_ChangeColour(0xFF00, 0xFFFF);
0777  0948             // Notes    : Changes the pixel colour in the currently focussed clipping region
0778  0949   
0779  0950             func gfx_FocusWindow(), 1;                      // focus on the clipping area, returning the pixel count
0780  0951             // Syntax   : gfx_FocusWindow();
0781  0952             // Usage    : var := gfx_FocusWindow();
0782  0953             // Notes    : sets the focus on the clipping region and returns number of pixels in the region.
0783  0954   
0784  0955             func gfx_SetClipRegion(), 1;                    // set clipping area to the most recent extents
0785  0956             // Syntax   : gfx_SetClipRegion();
0786  0957             // Usage    : VAR := gfx_SetClipRegion();
0787  0958             // Notes    :
0788  0959   
0789  0960             //==============================================//
0790  0961             // uSD/FLASH Function Prototypes                //
0791  0962             //==============================================//
0792  0963   
0793  0964             func media_Video("x", "y"), 0;                  // display movie at position x y
0794  0965             // Syntax   : media_Video(x, y);
0795  0966             // Usage    : media_Video(arg1, arg2);
0796  0967             // Notes    : Play a Video/Animation clip from the uSD card at screen location
0797  0968             //          : specified by x,y (top left corner). The location of the clip in the
0798  0969             //          : uSD card must be specified by media_setSector(Video_Sector_Add) function.
0799  0970   
0800  0971             func media_VideoFrame("x", "y","framenumber"), 0;// display required frame from a movie at x y
0801  0972             // Syntax   : media_VideoFrame(Frame_number);
0802  0973             // Usage    : arg1 := media_VideoFrame();
0803  0974             // Notes    : After a pointer to a valid video has been set with media_SetSector,
0804  0975             //          : calling this function shows each fram sequentially, returning
0805  0976             //          : the number of frames remaining. The position of the image is
0806  0977             //          : at the current origin as set with gfx_MoveTo(...);
0807  0978   
0808  0979             func media_SetAdd("HiWord", "LoWord"), 0;       // set stream byte address
0809  0980             // Syntax   : media_SetAdd(AddHiWord, AddLoWord);
0810  0981             // Usage    : media_SetAdd(arg1, arg2);
0811  0982             // Notes    : Set uSD internal Address pointer for bytewise access
0812  0983   
0813  0984             func media_SetSector("HiWord", "LoWord"), 0;    // set stream sector address
0814  0985             // Syntax   : media_SetSector(SectHiWord, SectLoWord);
0815  0986             // Usage    : media_SetSector(arg1, arg2);
0816  0987             // Notes    : Set uSD internal Sector pointer for sector block access
0817  0988   
0818  0989             func media_ReadByte(), 1;                       // read a byte at the current stream position
0819  0990             // Syntax   : media_RdByte();
0820  0991             // Usage    : var := media_RdByte();
0821  0992             // Notes    : Reads and Returns a single byte of data from the
0822  0993             //          : uSD card pointed to by the internal Address pointer.
0823  0994             //          : After the read the Address pointer is automatically
0824  0995             //          : incremented by 1.
0825  0996   
0826  0997             func media_ReadWord(), 1;                       // read a word at the current stream position
0827  0998             // Syntax   : media_ReadWord();
0828  0999             // Usage    : var := media_ReadWord();
0829  1000             // Notes    : Reads and Returns a single word of data from the
0830  1001             //          : uSD card pointed to by the internal Address pointer.
0831  1002             //          : After the read the Address pointer is automatically
0832  1003             //          : incremented by 1.
0833  1004   
0834  1005             func media_WriteByte("byte"), 1;                // write a byte to the current stream position
0835  1006             // Syntax   : media_WriteByte(arg1);
0836  1007             // Usage    : var := media_WriteByte(arg1);
0837  1008             // Notes    : Writes and Returns xxxxx
0838  1009             //          : After the write the Address pointer is automatically
0839  1010             //          : incremented by 1.
0840  1011   
0841  1012             func media_WriteWord("word"), 1;                // write a word to the current stream position
0842  1013             // Syntax   : media_WriteWord(arg1);
0843  1014             // Usage    : var := media_WriteWord(arg1);
0844  1015             // Notes    : Writes and Returns xxxxx
0845  1016             //          : After the write the Address pointer is automatically
0846  1017             //          : incremented by 1.
0847  1018   
0848  1019             func media_Image("x", "y"), 0;                  // display image at position x y
0849  1020             // Syntax   : media_Image(x, y);
0850  1021             // Usage    : media_Image(arg1, arg2);
0851  1022             // Notes    : Display an image from the uSD card at screen location
0852  1023             //          : specified by x,y (top left corner). The location of the
0853  1024             //          : Image in the uSD card must be specified by
0854  1025             //          : media_setSector(Image_Sector_Add) function.
0855  1026   
0856  1027             func media_Flush(), 1;                          // after writing to media, flush the sector and write
0857  1028             // Syntax   : media_Flush();
0858  1029             // Usage    : var := media_Flush();
0859  1030             // Notes    : After writing any data to a sector, media_Flush() should be called to ensure that the current sector that
0860  1031             //          : is being written is correctly stored back to the media else write operations may be unpredictable.
0861  1032   
0862  1033             func media_Init(), 1;                           // initialize uSD card
0863  1034             // Usage    : media_Init();
0864  1035             // Notes    : Initialise uSD CARD
0865  1036             //          : Response: 0 = No Card
0866  1037             //          :           1 = Card Initialised
0867  1038   
0868  1039   
0869  1040             //==============================================//
0870  1041             // RTTTL Specific Function Prototypes           //
0871  1042             //==============================================//
0872  1043   
0873  1044             func tune_Play("TunePtr"), 0;                   // play a RTTTL tune string
0874  1045             // Syntax   : tune_Play(TunePtr);
0875  1046             // Usage    : tune_Play("...notes...");
0876  1047             // Notes    : Play a tune string from a data statement or a direct string
0877  1048   
0878  1049             func tune_Pause(), 0;                           // pause RTTTL (sound continues at current note)
0879  1050             // Syntax   : tune_Pause();
0880  1051             // Usage    : tune_Pause();
0881  1052             // Notes    : Suspends any current tune from playing until a tune_Continue(),
0882  1053             //          : tune_Stop(); or a new tune_Play("...") function. The oscillator
0883  1054             //          : is not stopped
0884  1055   
0885  1056             func tune_Continue(), 0;                        // continue RTTTL
0886  1057             // Syntax   : tune_Continue();
0887  1058             // Usage    : tune_Continue();
0888  1059             // Notes    : Continues playing any previously stopped or paused tune
0889  1060   
0890  1061             func tune_Stop(), 0;                            // stop playing RTTTL tune, sound muted
0891  1062             // Syntax   : tune_Stop();
0892  1063             // Usage    : tune_Stop();
0893  1064             // Notes    : Pauses a tune and silences the oscillator until a tune_Continue(),
0894  1065             //          : tune_Stop(), tune_End or a new tune_Play("..."); function
0895  1066   
0896  1067             func tune_End(), 0;                             // cancel a RTTTL tune
0897  1068             // Syntax   : tune_End();
0898  1069             // Usage    : tune_End();
0899  1070             // Notes    : Ends any current tune and resets the tune interpreter
0900  1071   
0901  1072             func tune_Playing(), 1;                         // pol RTTTL player to see if a tune is playing
0902  1073             // Syntax   : tune_Playing();
0903  1074             // Usage    : var := tune_Playing();
0904  1075             // Notes    : returns 1 if tune is playing, 0 if no tune is playing.
0905  1076   
0906  1077             //==============================================//
0907  1078             // Communications Function Prototypes           //
0908  1079             //==============================================//
0909  1080             func com_AutoBaud("timeout"), 1;                // wait for timeout millisconds, retur baud rate if "U" received
0910  1081             // Syntax   : com_AutoBaud(timeout);
0911  1082             // Usage    : arg := com_AutoBaud(500);
0912  1083             //          : enter auto baud mode for "time" milliseconds, wait for "U"
0913  1084             //          : If timeout occurs, a 0 is returned, else the baud rate
0914  1085             //          : divisor calculated is returned for verification if required.
0915  1086   
0916  1087             func com_Init("buf","bufsize","qualifier"), 0;  // set up a interrupt driven ring buffer for comms
0917  1088             // Syntax   : com_Init(buffer, bufsize, qualifier);
0918  1089             // Usage1   : com_Init(mybuf, 20, 0);
0919  1090             // Usage2   : com_Init(mybuf, 20, ':');
0920  1091             // Notes    : initialize a serial capture buffer for the comms input
0921  1092             //          : The program must declare a var array as a circular buffer.
0922  1093             //          : Usage1 declares a circular buffer which will continually
0923  1094             //          : buffer characters.
0924  1095             //          : Usage2 must receive ':' before any characters will
0925  1096             //          : accumulate in the buffer.
0926  1097   
0927  1098             func com_Reset(), 0;                            // reset the ring buffer
0928  1099             // Syntax   : com_Reset();
0929  1100             // Usage    : com_Reset();
0930  1101             // Notes    : reset comms to default polled mode
0931  1102   
0932  1103             func com_Count(), 1;                            // return count of characters in ring buffer
0933  1104             // Syntax   : com_Count();
0934  1105             // Usage    : arg := com_Count();
0935  1106             // Notes    : return count of buffered characters in buffer attachment
0936  1107   
0937  1108             func com_Full(), 1;                             // return TRUE if com buffer filled to capcity
0938  1109             // Syntax   : com_Full();
0939  1110             // Usage    : if (com_Full() ,,,, go read buffer;
0940  1111             // Notes    : return true if buffer full (not necessarily an error if buffer is sized to a packet size)
0941  1112   
0942  1113             func com_Error(), 1;                            // return TRUE if a comms error occurred
0943  1114             // Usage    : if (com_Error() ) ...... take recovery action;
0944  1115             // Notes    : Returns 1 if any low level communications error occurred, else returns 0.
0945  1116   
0946  1117             func com_Sync(), 1;                             // returns TRUE if qualifier has been received
0947  1118             // Syntax   : com_Sync();
0948  1119             // Usage    : var := com_Sync();
0949  1120             // Notes    : return true if sync character has been received in com_Init("...") mode
0950  1121   
0951  1122             func com_Checksum(), 1;                         // returns checksum if employed. 0 = OK
0952  1123             // Syntax   : com_Checksum();
0953  1124             // Usage    : if(!com_Checksum()); processMyPacket();
0954  1125             // Notes    : Transparent to normal operation, a check summing system is operating. If the host sends one extra
0955  1126             //          : character as part of the packet (usually added at the end of the packet) which is the negated value of the
0956  1127             //          : addition of all the previous characters in the packet. Once the com_Full() function reports a buffer full
0957  1128             //          : situation (ie the packet is fully received) , the checksum can be read, and should read zero if the packet
0958  1129             //          : is not corrupted.
0959  1130             //          :
0960  1131             //          : Returns 0 if checksum has been computed correctly.
0961  1132   
0962  1133             func com_PacketSize(), 1;                       // returns size of the comms buffer for packet mode
0963  1134             // Syntax   : com_PacketSize();
0964  1135             // Usage    : If (!com_Count()); print("Waiting....");
0965  1136             // Notes    : com_PacketSize() will indicate how large the packet is ONLY after the packet reception has started.
0966  1137             //          : Although it is usually not required to know the packet size until the packet has actually been read, if it
0967  1138             //          : is a requirement, the count is available as soon as com_Count() becomes non zero. If not in variable
0968  1139             //          : packet length mode, com_PacketSize() just returns the size of the specified buffer.
0969  1140             //          :
0970  1141             //          : Returns the size of a packet if in variable packet length mode, or just the size of the serial buffer if
0971  1142             //          : not variable packet length mode.
0972  1143   
0973  1144             //==============================================//
0974  1145             // Display Initialization                       //
0975  1146             // (for GOLDELOX-GFX2 with external display)    //
0976  1147             //==============================================//
0977  1148   
0978  1149             func disp_Init("INIT_table", "GRAM_code"), 0;   // initialize display with required tables
0979  1150             // Syntax   : disp_Init(initTable, stateMachine);
0980  1151             // Usage    : disp_Init(INIT_tbl, GRAM_sm);
0981  1152             // Notes    : The GOLDELOX-GFX2 needs to be aware of all the display registers and how to access them.
0982  1153             //          : The initialisation and the state machine tables are necessary to achieve this. Refer to the individual
0983  1154             //          : display data sheet available from the display manufacturer.
0984  1155             //          : For hardware platform modules such as uOLED-96-G1(GFX), uOLED-128-G1(GFX), etc the disp_Init(,,) is not
0985  1156             //          : needed. The modules are factory set-up with their display specific configurations.
0986  1157             //          :
0987  1158             //          : initTable   : A reference to the device initialisation table which is stored as a data statement.
0988  1159             //          : stateMachine: A reference to the device state machine table which is stored as a data statement.
0989  1160             //          :
0990  1161   
0991  1162             //==============================================//
0992  1163             // Display Access                               //
0993  1164             //==============================================//
0994  1165   
0995  1166             func disp_WriteByte("value"), 0;                // write a data byte to the display
0996  1167             // Syntax: disp_WriteByte(value);
0997  1168             // Usage    : on a SD1339 display driver IC
0998  1169             //          : #constant DRAW_CIRCLE 0x86
0999  1170             //          : func myCircle(var x, var y, var r, var fillcolour, var linecolour)
1000  1171             //          :     disp_WriteControl(DRAW_CIRCLE);   // Draw Circle command
1001  1172             //          :     disp_WriteByte(x);                // set x1
1002  1173             //          :     disp_WriteByte(y);                // set y1
1003  1174             //          :     disp_WriteByte(r);                // set x2
1004  1175             //          :     disp_WriteByte(linecolour>>8);    // set outline colour Hi byte
1005  1176             //          :     disp_WriteByte(linecolour);       // set outline colour Lo byte
1006  1177             //          :     disp_WriteByte(fillcolour>>8);    // set fill colour Hi byte
1007  1178             //          :     disp_WriteByte(fillcolour);       // set fill colour Lo byte
1008  1179             //          : endfunc
1009  1180             // Notes    : Sends a single byte (which is the lower 8 bits of value) to the display bus. Refer to individual data
1010  1181             //          : sheets for the display for more information. This function is used to extend the capabilities of the user
1011  1182             //          : code to gain access to the the display hardware.
1012  1183             //          :
1013  1184             //          : value Specifies the value to be written to the display data register. Only the lower 8 bits are sent to
1014  1185             //          : the display.
1015  1186   
1016  1187             func disp_WriteControl("value"), 0;             // write a control byte to the display
1017  1188             // Syntax: disp_WriteControl("value");
1018  1189             // Usage    : on a SD1339 display driver IC
1019  1190             //          : #constant DRAW_CIRCLE 0x86
1020  1191             //          : func myCircle(var x, var y, var r, var fillcolour, var linecolour)
1021  1192             //          :     disp_WriteControl(DRAW_CIRCLE);   // Draw Circle command
1022  1193             //          :     disp_WriteByte(x);                // set x1
1023  1194             //          :     disp_WriteByte(y);                // set y1
1024  1195             //          :     disp_WriteByte(r);                // set x2
1025  1196             //          :     disp_WriteByte(linecolour>>8);    // set outline colour Hi byte
1026  1197             //          :     disp_WriteByte(linecolour);       // set outline colour Lo byte
1027  1198             //          :     disp_WriteByte(fillcolour>>8);    // set fill colour Hi byte
1028  1199             //          :     disp_WriteByte(fillcolour);       // set fill colour Lo byte
1029  1200             //          : endfunc
1030  1201             // Notes    : Sends a single byte (which is the lower 8 bits of value) to the display bus. Refer to individual data
1031  1202             //          : sheets for the display for more information. This function is used to extend the capabilities of the user
1032  1203             //          : code to gain access to the the display hardware.
1033  1204             //          : value Specifies the value to be written to the display control register. Only the lower 8 bits are sent to
1034  1205             //          : the display.
1035  1206   
1036  1207             func disp_WriteWord("value"), 0;                // write a word (HI:LO format) to the display
1037  1208             // Syntax   : disp_WriteWord(value);
1038  1209             // Usage    : on a SD1339 display driver IC
1039  1210             //          : #constant DRAW_CIRCLE 0x86
1040  1211             //          : func myCircle(var x, var y, var r, var fillcolour, var linecolour)
1041  1212             //          :     disp_WriteControl(DRAW_CIRCLE);   // Draw Circle command
1042  1213             //          :     disp_WriteByte(x);                // set x1
1043  1214             //          :     disp_WriteByte(y);                // set y1
1044  1215             //          :     disp_WriteByte(r);                // set x2
1045  1216             //          :     disp_WriteWord(linecolour);       // set outline colour
1046  1217             //          :     disp_WriteWord(fillcolour);       // set fill colour
1047  1218             //          : endfunc
1048  1219             // Notes    : Sends a 16 bit value to the display bus. Since the GOLDELOX-GFX2 display data bus is 8bits wide, the HIGH
1049  1220             //          : byte is sent first followed by the LOW byte. Refer to individual data sheets for the display for more
1050  1221             //          : information. This function is used to extend the capabilities of the user code to gain access to the the
1051  1222             //          : display hardware.
1052  1223             //          :
1053  1224             //          : value Specifies the value to be written to the display data register. Only the lower 8 bits are sent to
1054  1225             //          : the display.
1055  1226   
1056  1227             func disp_ReadByte(), 1;                        // read a byte from the display
1057  1228             // Syntax   : disp_ReadByte();
1058  1229             // Usage    : gfx_ClipWindow(40,40,44,44); // within a small block on the display
1059  1230             //          : gfx_FocusWindow(); // focus GRAM
1060  1231             //          : pixel_Hi:= dispReadByte(); // read hi byte of first pixel
1061  1232             //          : pixel_Lo:= dispReadByte(); // read lo byte of first pixel
1062  1233             // Notes    : Reads a byte from the display after an internal register or GRAM access has been set.
1063  1234             //          : value Returns the 8bit data that was read from the display. Only the lower 8bits are valid.
1064  1235   
1065  1236             func disp_ReadWord(), 1;                        // read a word from the display (HI:LO format)
1066  1237             // Syntax   : disp_ReadWord();
1067  1238             // Usage    : gfx_ClipWindow(40,40,44,44); // within a small block on the display
1068  1239             //          : gfx_FocusWindow(); // focus GRAM
1069  1240             //          : pixel := dispReadWord(); // read 1st pixel, HI:LO order
1070  1241             // Notes    : Reads a 16bit word from the display after an internal register or GRAM access has been set.
1071  1242             //          : Returns the 16bit data that was read from the display.
1072  1243   
1073  1244             func disp_BlitPixelFill("colr","count"), 0;      // write "count" pixels to the display (8 or 16 bit)
1074  1245             // Syntax   : disp_BlitPixelFill(colour, count);
1075  1246             // Usage    : gfx_ClipWindow(40,40,79,79); // select a block on the display
1076  1247             //          : count := gfx_FocusWindow(); // focus GRAM
1077  1248             //          : myvar:=dispBlitPixelFill(RED,count); // paint the area red
1078  1249             // Notes    : Fills a preselected GRAM screen area with the specified colour. colour Specifies the colour for the
1079  1250             //          : fill. count Specifies the number of pixels to fill.
1080  1251             //          : The arguments can be a variable, array element, expression or constant
1081  1252   
1082  1253             func disp_BlitPixelsToMedia(), 1;               // write current clip window to the media (8 or 16 bit), return pixel count
1083  1254             // Syntax   : disp_BlitPixelsToMedia();
1084  1255             // Usage    : media_SetSector(0x0020,0x0000); // we're going to write here
1085  1256             //          : n:=disp_BlitPixelsToMedia (); // save it to sector
1086  1257             // Notes    : Write the selected GRAM area to the media at the current media address. Needs a uSD card.
1087  1258             //          : Returns the number of pixels that were written to the media.
1088  1259   
1089  1260             func disp_BlitPixelsFromCOM("mode"), 0;         // write pixels from the serial port to the currnetly focused GRAM area (8 or 16 bit)
1090  1261             // Syntax   : disp_BlitPixelFromCOM(mode);
1091  1262             // Usage    : gfx_ClipWindow(40,40,59,59); // writing to a 40x40 block on the display.
1092  1263             //          : gfx_FocusWindow(); // NB first focus is just so we can get pixel count of area.
1093  1264             //          : print("Filling ",*IMG_PIXEL_COUNT," pixels");
1094  1265             //          : gfx_FocusWindow();
1095  1266             //          : disp_BlitPixelsFromCOM(0); // get pixels from serial port,
1096  1267             //          : while(*IMG_PIXEL_COUNT); // wait till all the pixels come in
1097  1268             // Notes    : Fills a preselected GRAM screen area with the specified colour.
1098  1269             //          : mode = 0 : specifies 16 bit pixels
1099  1270             //          : mode = pointer : specifies pointer to 16 element colour lookup table for each 4bit pixel value
1100  1271             //          : The arguments can be a variable, array element, expression or constant
1101  1272   
1102  1273             func disp_BlitPixelsToCOM(), 1;                 // write current clip window to the com port (8 or 16 bit), return pixel count
1103  1274             // Syntax   : disp_BlitPixelsToCOM();
1104  1275             // Usage    : gfx_ClipWindow(40,40,44,44);  // within a small block on the display
1105  1276             //          : pixels:=gfx_FocusWindow(); // focus GRAM and get pixel count of area
1106  1277             //          : disp_BlitPixelFill(0x4142, pixels);// fill the area using ASCII values so we can read easily
1107  1278             //          : disp_BlitPixelsToCOM(); // write the pixels to the COM port
1108  1279             // Notes    : Write the selected GRAM area to the serial (COM) port..
1109  1280             //          : Returns the number of pixels that were written to the serial port.
1110  1281   
1111  1282             func disp_BlitPixelsFromMedia("count"), 0;      // write "count" pixels from the current media (default uSD) to the display (8 or 16 bit)
1112  1283             // Syntax   : disp_BlitPixelsFromMedia(pixelcount);
1113  1284             // Usage    : media_SetAdd(0x0002, 0x3C00); // point to required area of an image
1114  1285             //          : disp_BlitPixelsFromMedia(20); // write the next 20 pixels from media to the current GRAM pointer.
1115  1286             // Notes    : Read the required number of pixels consecutively from the current media stream and write
1116  1287             //          : them to the current display GRAM address. For 8bit colour mode, each pixel comprises a single 8bit value.
1117  1288             //          : For 16bit colour, each pixel is composed of 2 bytes, the high order byte is read first, the low order bye
1118  1289             //          : is read next.
1119  1290             //          : pixelcount Specifying the number of pixels to be consecutively read from the media stream.
1120  1291             //          : The arguments can be a variable, array element, expression or constant
1121  1292   
1122  1293             func disp_SkipPixelsFromMedia("count"), 0;      // skip "count" pixels from the current media (default uSD) to the display (8 or 16 bit)
1123  1294             // Syntax   : disp_SkipPixelsFromMedia("count");
1124  1295             // Usage    : disp_SkipPixelsFromMedia(20); // skip the next 20 pixels from media
1125  1296             //          : disp_BlitPixelsFromMedia(20); // write the next 20 pixels from media to the current GRAM pointer.
1126  1297             // Notes    : Skip the required number of pixels consecutively from the current media stream, discarding them. For 8bit
1127  1298             //          : colour mode, each pixel comprises a single 8bit value. For 16bit colour, each pixel is composed of 2
1128  1299             //          : bytes, the high order byte is read first, the low order bye is read next.
1129  1300             //          :
1130  1301             //          : pixelcount Specifying the number of pixels to be consecutively skipped from the media stream.
1131  1302             //          : The arguments can be a variable, array element, expression or constant
1132  1303   
1133  1304             //==============================================//
1134  1305             // unadorned SPI functions                      //
1135  1306             //==============================================//
1136  1307   
1137  1308             func spi_Init("speed","ip_mode","op_mode"), 0;  // set the SPI port, not used if uSD active
1138  1309             // Syntax   : spi_Init(speed, input_mode, output_mode);
1139  1310             // Usage    : spi_Init(speed,ip_mode,op_mode);
1140  1311             // Notes    : Sets up the GOLDELOX-GFX2 SPI port to communicate with SPI devices.
1141  1312             //          : Note: The SPI functions in this section are not necessary when using the memory card or serial flash chips
1142  1313             //          : interfaced to the SPI port. The SPI functions in this section are relevant to those devices other than the
1143  1314             //          : memory card and the serial flash chip used for media access.
1144  1315             //          : speed         : Sets the speed of the SPI port.
1145  1316             //          : input_mode    : Sets the input mode of the SPI port.
1146  1317             //          : output_mode   : Sets the output mode of the SPI port. See diagram below.
1147  1318             //          : The arguments can be a variable, array element, expression or constant
1148  1319   
1149  1320             func spi_Read(), 1;                             // read a raw byte from SPI (lowers CS)
1150  1321             // Syntax   : spi_Read();
1151  1322             // Usage    : var := spi_Read();
1152  1323             // Notes    : This function allows a raw unadorned byte read from the SPI device.
1153  1324             //          : Note: The Chip Select line (SDCS) is lowered automatically.
1154  1325             //          : Returns a single data byte from the SPI device.
1155  1326   
1156  1327             func spi_Write("byte"), 0;                      // write a raw byte to SPI (lowers CS)
1157  1328             // Syntax   : spi_Write("byte");
1158  1329             // Usage    : spi_Write(byte);
1159  1330             // Notes    : This function allows a raw unadorned byte write to the SPI device.
1160  1331             //          : Note: The Chip Select line (SDCS) is lowered automatically.
1161  1332             //          : byte specifies the data byte to be sent to the SPI device.
1162  1333   
1163  1334             func spi_Disable(), 0;                          // disable SPI reading or writing (raise CS)
1164  1335             // Syntax   : spi_Disable();
1165  1336             // Usage    : spi_Disable();
1166  1337             // Notes    : This function raises the Chip Select (SDCS) line of the SPI device, disabling it from further activity.
1167  1338             //          : The CS line will be automatically lowered next time the SPI functions spi_Read() or spi_Write(...) are
1168  1339             //          : used, and also by action of any of the media_ functions.
1169  1340   
1170  1341   
1171  1342             //==============================================//
1172  1343             // flash device specific functions              //
1173  1344             //==============================================//
1174  1345   
1175  1346             func flash_SIG(), 1;                            // read Jedecsignature from SPI Flash device
1176  1347             // Syntax   : flash_SIG();
1177  1348             // Usage    : var := flash_SIG();
1178  1349             // Notes    : If a FLASH storage device is connected to the SPI port, and has been correctly initialised with the
1179  1350             //          : spi_Init(...) function, the Electronic Signature of the device can be read using this function. The only
1180  1351             //          : devices supported so far on the GOLDELOX-GFX2 are the M25Pxx range of devices which are 512Kbit to 32Mbit
1181  1352             //          : (2M x 8) Serial Flash Memory.
1182  1353             //          : Release from Deep Power-down, and Read Electronic Signature. Only the low order byte is valid, the upper
1183  1354             //          : byte is ignored.
1184  1355   
1185  1356             func flash_ID(), 1;                             // read ID code from FLASH device
1186  1357             // Syntax   : flash_ID();
1187  1358             // Usage    : var := flash_ID();
1188  1359             // Notes    : If a FLASH storage device is connected to the SPI port, and has been correctly initialised with the
1189  1360             //          : spi_Init(...) function, the memory type and capacity from the flash device can be read using this function
1190  1361             //          : The only devices supported so far on the GOLDELOX-GFX2 are the M25Pxx range of devices which are 512Kbit to
1191  1362             //          : 32Mbit (2M x 8) Serial Flash Memory.
1192  1363             //          : Reads the memory type and capacity from the serial FLASH device. Hi byte contains type, and low byte
1193  1364             //          : contains capacity. Refer to the device data sheet for further information.
1194  1365   
1195  1366             func flash_BulkErase(), 0;                      // erase the entire FLASH device
1196  1367             // Syntax   : flash_BulkErase();
1197  1368             // Usage    : flash_BulkErase();
1198  1369             // Notes    : If a FLASH storage device is connected to the SPI port, and has been correctly initialised with the
1199  1370             //          : spi_Init(...) function, the FLASH device can be completely erased using this function. The only devices
1200  1371             //          : supported so far on the GOLDELOX-GFX2 are the M25Pxx range of devices which are 512Kbit to 32Mbit (2M x 8)
1201  1372             //          : Serial Flash Memory.
1202  1373             //          : Erases the entire flash media device. The function returns no value, and the operation can take up to 80
1203  1374             //          : seconds depending on the size of the flash device.
1204  1375   
1205  1376             func flash_BlockErase("block"), 1;              // erase the required 64k flash block
1206  1377             // Syntax   : flash_BlockErase("block")
1207  1378             // Usage    : var := flash_BlockErase(block_num)
1208  1379             // Notes    : If a FLASH storage device is connected to the SPI port, and has been correctly initialised with the
1209  1380             //          : spi_Init(...) function, the FLASH block can be erased using this function. The only devices supported so
1210  1381             //          : far on the GOLDELOX-GFX2 are the M25Pxx range of devices which are 512Kbit to 32Mbit (2M x 8) Serial Flash
1211  1382             //          : Memory.
1212  1383             //          : E.g. there are 32 x 64K blocks on a 2Mb flash device.
1213  1384             //          : blockAddress The address of the 64k FLASH block to be erased.
1214  1385             //          : Erases the required block in a FLASH media device. The function returns no value, and the operation
1215  1386             //          : can take up to 3 milliseconds.
1216  1387   
1217  1388             //==============================================//
1218  1389             // user stack operations                        //
1219  1390             //==============================================//
1220  1391   
1221  1392             func setsp("offset"), 0;                        // set the user stack pointer (same as pokeW(USR_SP, n); )
1222  1393             // Syntax   : setsp(index);
1223  1394             // Usage    : setsp(0); // reset the stack pointer
1224  1395             // Notes    : The users stack pointer is zeroed at power up, but it is sometimes necessary to alter the stack pointer
1225  1396             //          : for various reasons, such as running multiple concurrent stacks, or resetting to a known position as part
1226  1397             //          : of an error recovery process.
1227  1398             //          : index: This argument is used to set the users SP to the required position. The stack pointer is set to
1228  1399             //          : zero during power-up initialisation.
1229  1400   
1230  1401             func getsp(), 1;                                // return the current stack pointer (same as peekW(USR_SP); )
1231  1402             // Usage    : push(1234);
1232  1403             //          : print(getsp()); // print the stack index
1233  1404             // Notes    : This function returns the current stack index into the stack array. If the index is zero, there are no
1234  1405             //          : items on the stack.
1235  1406             //          : index: The current stack index.
1236  1407   
1237  1408             func pop(), 1;                                  // pop var off stack
1238  1409             // Syntax   : pop();
1239  1410             // Usage    : push(100);
1240  1411             //          : push(200);
1241  1412             //          : print(pop()+ pop());
1242  1413             // Notes    : This function returns the value at the current stack pointer index. The stack pointer is then
1243  1414             //          : decremented, so it now points to the item below. If the stack pointer is zero, (ie a pop was performed on
1244  1415             //          : an empty stack) the function returns 0 and the stack pointer is not altered (ie it remains at 0).
1245  1416             //          : Returns the value at current stack pointer index.
1246  1417   
1247  1418             func drop("count"), 0;                          // drop n vars off stack
1248  1419             // Syntax   : drop(count);
1249  1420             // Usage    : myvar := 10;
1250  1421             //          : push(1234);
1251  1422             //          : push(5678);
1252  1423             //          : push(myvar);
1253  1424             //          : drop(2);
1254  1425             // Notes    : Decrements the user stack pointer determined by the value n. If n exceeds the stack index, the stack
1255  1426             //          : pointer is zeroed.
1256  1427             //          : count Specifies the number of items to be dropped from the stack.
1257  1428   
1258  1429             func push("item"), 1;                           // push value to stack
1259  1430             // Syntax   : push(val);
1260  1431             // Usage    : Myvar := 10;
1261  1432             //          : push(1234);
1262  1433             //          : push(5678);
1263  1434             //          : push(myvar);
1264  1435             // Notes    : Increment the user stack pointer first and then places the item into the user stack array at the current
1265  1436             //          : position. The stack pointer is now pointing to this new item.
1266  1437             //          : val: Argument to be pushed to the user stack.
1267  1438   
1268  1439             func call(), 1;                                 // exec a function using stacked frame (frame is dropped)
1269  1440             // Syntax   : call()
1270  1441             // Usage    : push(10);
1271  1442             //          : push(10);
1272  1443             //          : push(50);
1273  1444             //          : push(50);
1274  1445             //          : push(0xFFFF);
1275  1446             //          : push(gfx_RectangleFilled); // push the function call address
1276  1447             //          : push(5); // push the argument count
1277  1448             //          : //~~~~~~~
1278  1449             //          : call();
1279  1450             // Notes    : Calls the specified function, the arguments to the called function are from the stack. The stacked
1280  1451             //          : parameters are consumed and the stack pointer is altered to match the number of arguments that were
1281  1452             //          : consumed.
1282  1453             //          : value: If the called function returns a value then it is available.
1283  1454   
1284  1455             func exec("func","argcnt"), 1;                  // exec a function using stacked parameters (parameters remain)
1285  1456             // Syntax   : exec("func","argcnt");
1286  1457             // Usage    : Push(50); // set some arbitrary values on the stack
1287  1458             //          : push(50);
1288  1459             //          : push(10);
1289  1460             //          : push(YELLOW);
1290  1461             //          : //~~~~~~~
1291  1462             //          : exec(gfx_Circle,4); // exec the circle function using the stacked parameters
1292  1463             // Notes    : Calls the specified function, passing the arguments to the called function from the stack. The stack and
1293  1464             //          : stack pointer are not altered.
1294  1465             //          : functionPtr A pointer to a function which will utilise the stacked arguments. argCount The count of
1295  1466             //          : arguments on the stack that are to be passed to the function call.
1296  1467             //          : The arguments can be a variable, array element, expression or constant.
1297  1468   
1298  1469             //==============================================//
1299  1470             // size modifier                                //
1300  1471             //==============================================//
1301  1472   
1302  1473             func iterator("offset"), 0;                     // set the iterator size for ++/-- (same as pokeW(INCVAL, n);
1303  1474             // Syntax   : iterator("offset");
1304  1475             // Usage    : iterator(arg);
1305  1476             // Notes    :
1306  1477   
1307  1478             //==============================================//
1308  1479             // string and character size function           //
1309  1480             //==============================================//
1310  1481   
1311  1482             func strlen("pointer"), 1;                      // return length of a string in character units
1312  1483             // Syntax   : strlen("pointer");
1313  1484             // Usage    : var := strlen(Str);
1314  1485             // Notes    : strlen returns the length of a zero terminated string in character units. Note that any string constants
1315  1486             //          : declared in your program are automatically terminated with a zero as an end marker by the compiler. Any
1316  1487             //          : string that you create in the DATA section or MEM section must have a zero added as a terminator for this
1317  1488             //          : function to work correctly.
1318  1489             //          : pointer: The pointer to a zero (0x00) terminated string.
1319  1490             //          : Returns the length of a string in character units.
1320  1491   
1321  1492             func charwidth("char"), 1;                          // return width of a character in pixel units
1322  1493             // Syntax   : charwidth("char");
1323  1494             // Usage    : txt_FontID(MS_SanSerif8x12); // select this font
1324  1495             //          : w := charwidth('W');  // get a characters width
1325  1496             // Notes    : charwidth is used to calculate the width in pixel units for a string, based on the currently selected
1326  1497             //          : font. The font can be proportional or mono-spaced. If the total width of the string exceeds 255 pixel
1327  1498             //          : units, the function will return the 'wrapped' (modulo 8) value.
1328  1499             //          : char: The ascii character for the width calculation.
1329  1500             //          : Returns the width of a single character in pixel units.
1330  1501   
1331  1502             func charheight("char"), 1;                         // return height of a character in pixel units
1332  1503             // Syntax   : charheight("char");
1333  1504             // Usage    : txt_FontID(MS_SanSerif8x12); // select this font
1334  1505             //          : w := charheight('W'); // get a characters width
1335  1506             // Notes    : charheight is used to calculate the height in pixel units for a string, based on the currently selected
1336  1507             //          : font. The font can be proportional or mono-spaced.
1337  1508             //          : char: The ascii character for the height calculation.
1338  1509             //          : Returns the height of a single character in pixel units.
1339  1510   
1340  1511             func strwidth("pointer"), 1;                    // return width of a string in pixel units
1341  1512             // Syntax   : strwidth("pointer");
1342  1513             // Usage    : var := strwidth(Str);
1343  1514             // Notes    : strwidth returns the width of a zero terminated string in pixel units. Note that any string constants
1344  1515             //          : declared in your program are automatically terminated with a zero as an end marker by the compiler. Any
1345  1516             //          : string that you create in the DATA section or MEM section must have a zero added as a terminator for this
1346  1517             //          : function to work correctly.
1347  1518             //          : pointer: The pointer to a zero (0x00) terminated string.
1348  1519             //          : Returns the width of a string in pixel units.
1349  1520   
1350  1521             func strheight(), 1;                            // return height of a string in pixel units
1351  1522             // Syntax   : strheight(Str);
1352  1523             // Usage    : var := strheight();
1353  1524             // Notes    : strheight returns the height of a zero terminated string in pixel units. The strwidth function must be
1354  1525             //          : called first which makes available width and height. Note that any string constants declared in your
1355  1526             //          : program are automatically terminated with a zero as an end marker by the compiler. Any string that you
1356  1527             //          : create in the DATA section or MEM section must have a zero added as a terminator for this function to work
1357  1528             //          : correctly.
1358  1529             //          : Returns the height of a string in pixel units.
1359  1530   
1360  1531             //==============================================//
1361  1532             // extended functions                           //
1362  1533             //==============================================//
1363  1534   
1364  1535             func EVE_SP(), 1;                               // current EVE stack pointer
1365  1536             // Syntax   : EVE_SP();
1366  1537             // Usage    : var := EVE_SP();
1367  1538             // Notes    : returns the EVE stack pointer, useful for fault finding
1368  1539             //          : and checking for stack limits. Eve stack is 0x300 to 0x3FF
1369  1540             //          : Your application should not take stack above 0x3C0 to allow
1370  1541             //          : room for internal use.
1371  1542   
1372  1543   
1373  1544             //==============================================//
1374  1545             // Single parameter short-cuts                  //
1375  1546             // for the txt_Set functions                    //
1376  1547             //==============================================//
1377  1548   
1378  1549             func txt_FGcolour("colour"), 0;                 // 0  text foreground colour
1379  1550             // Syntax   : txt_FGcolour("colour")
1380  1551             // Usage    : txt_FGcolour(colr);
1381  1552             // Notes    : Change text foreground color
1382  1553   
1383  1554             func txt_BGcolour("colour"), 0;                 // 1  text background colour
1384  1555             // Syntax   : txt_BGcolour("colour");
1385  1556             // Usage    : txt_BGcolour(colr);
1386  1557             // Notes    : Change text background color
1387  1558   
1388  1559             func txt_FontID("id"), 0;                       // 2  text font ID (0 = system font)
1389  1560             // Syntax   : txt_FontID("id");
1390  1561             // Usage    : txt_FontID(font_num);
1391  1562             // Notes    : Set font type
1392  1563   
1393  1564             func txt_Width("multiplier"), 0;                // 3  text width multiplier
1394  1565             // Syntax   : txt_Width("multiplier");
1395  1566             // Usage    : txt_Width(arg);
1396  1567             // Notes    : Multiply the text width by x times.
1397  1568   
1398  1569             func txt_Height("multiplier"), 0;               // 4  text height multiplier
1399  1570             // Syntax   : txt_Height("multiplier");
1400  1571             // Usage    : txt_Height(arg);
1401  1572             // Notes    :  Multiply the text height by x times.
1402  1573   
1403  1574             func txt_Xgap("pixelcount"), 0;                 // 5  text gap between characters
1404  1575             // Syntax   : txt_Xgap("pixelcount");
1405  1576             // Usage    : txt_Xgap(arg);
1406  1577             // Notes    : Set gap between two consecutive characters
1407  1578   
1408  1579             func txt_Ygap("pixelcount"), 0;                 // 6  text gap between lines
1409  1580             // Syntax   : txt_Ygap("pixelcount");
1410  1581             // Usage    : txt_Ygap(arg);
1411  1582             // Notes    : Set gap between two consecutive rows of characters
1412  1583   
1413  1584             func txt_Delay("millisecs"), 0;                 // 7  text printing delay factor
1414  1585             // Syntax   : txt_Delay("millisecs");
1415  1586             // Usage    : txt_Delay(arg);
1416  1587             // Notes    : Text printing delay
1417  1588   
1418  1589             func txt_Opacity("mode"), 0;                    // 8  text OPAQUE or TRANSPARENT
1419  1590             // Syntax   : txt_Opacity("mode");
1420  1591             // Usage    : txt_Opacity(arg);
1421  1592             // Notes    : Set text to be opaque or transparent
1422  1593             //          : 0 for opaque
1423  1594             //          : 1 for transparent
1424  1595   
1425  1596             func txt_Bold("mode"), 0;                       // 9  text bold ON/OFF
1426  1597             // Syntax   : txt_Bold("mode");
1427  1598             // Usage    : txt_Bold(arg);
1428  1599             // Notes    : Set bold text on or off
1429  1600             //          : 0 bold off
1430  1601             //          : 1 bold on
1431  1602   
1432  1603             func txt_Italic("mode"), 0;                     // 10 text italic ON/OFF
1433  1604             // Syntax   : txt_Italic("mode");
1434  1605             // Usage    : txt_Italic(arg);
1435  1606             // Notes    : Set Itallic text on or off
1436  1607             //          : 0 Itallic off
1437  1608             //          : 1 Itallic on
1438  1609   
1439  1610             func txt_Inverse("mode"), 0;                    // 11 text inverse ON/OFF
1440  1611             // Syntax   : txt_Inverse("mode");
1441  1612             // Usage    : txt_Inverse(arg);
1442  1613             // Notes    : Set inverse text on or off
1443  1614             //          : 0 Inverse off
1444  1615             //          : 1 Inverse on
1445  1616   
1446  1617             func txt_Underline("mode"), 0;                  // 12 text underline ON/OFF
1447  1618             // Syntax   : txt_Underline("mode");
1448  1619             // Usage    : txt_Underline(arg);
1449  1620             // Notes    : Set Underline text on or off
1450  1621             //          : 0 Underlining off
1451  1622             //          : 1 Underlining on
1452  1623   
1453  1624             func txt_Attributes("value"), 0;                // 13 text combined bold|italic|inverse|underline
1454  1625             // Syntax   : txt_Attributes("value");
1455  1626             // Usage    : txt_Attributes(arg);
1456  1627             // Notes    : text combined bold|italic|inverse|underline, enabled or disabled simultaneously
1457  1628             //          : 0 : bold|italic|inverse|underline disabled
1458  1629   
1459  1630             func _1E(), 0;                                  // 14 text reserved
1460  1631             func _1F(), 0;                                  // 15 text reserved
1461  1632   
1462  1633             //==============================================//
1463  1634             // Single parameter short-cuts                  //
1464  1635             // for the gfx_Set functions                    //
1465  1636             //==============================================//
1466  1637   
1467  1638             func gfx_PenSize("mode"), 0;                    // 0  graphics pen size, SOLD or OUTLINE
1468  1639             // Syntax   : gfx_PenSize("mode");
1469  1640             // Usage    : gfx_PenSize("mode");
1470  1641             // Notes    : Set pen size.
1471  1642             //          : 0 Solid object
1472  1643             //          : 1 Outline object
1473  1644   
1474  1645             func gfx_BGcolour("colour"), 0;                 // 1  graphics background colour
1475  1646             // Syntax   : gfx_BGcolour("colour");
1476  1647             // Usage    : gfx_BGcolour(colr");
1477  1648             // Notes    : Sets background color of the screen
1478  1649             //          : value = 0 to 0xFFFF, Black to White
1479  1650   
1480  1651             func gfx_ObjectColour("colour"), 0;             // 2  graphics object colour
1481  1652             // Syntax   : gfx_ObjectColour("colour");
1482  1653             // Usage    : gfx_ObjectColour(colr);
1483  1654             // Notes    : Sets the Object colour used in various functions
1484  1655             //          : value = 0 to 0xFFFF, Black to White
1485  1656             //          : LineTo(,,); LineRel(,,); BoxTo(,,); Dot(); etc.
1486  1657   
1487  1658             func gfx_Clipping("mode"), 0;                   // 3  graphics clipping ON/OFF
1488  1659             // Syntax   : gfx_Clipping("mode");
1489  1660             // Usage    : gfx_Clipping("mode");
1490  1661             // Notes    : Set clipping mode
1491  1662             //          : 0 : Clipping disabled
1492  1663             //          : 1 : Clipping enabled
1493  1664   
1494  1665             func gfx_TranparentColour("colour"), 0;         // 4  graphics image transparent mask colour
1495  1666             // Syntax   : gfx_TranparentColour("colour");
1496  1667             // Usage    : gfx_TranparentColour("colr");
1497  1668             // Notes    : Sets Bitmap, Image or Animation Transparency Colour
1498  1669             //          : value = 0 to 0xFFFF Black to White
1499  1670   
1500  1671             func gfx_Tranparency("mode"), 0;                // 5  graphics image transparent mode ON/OFF
1501  1672             // Syntax   : gfx_Tranparency("mode");
1502  1673             // Usage    : gfx_Tranparency("mode");
1503  1674             // Notes    : Enables/Disables the Transparency feature
1504  1675             //          : 0 : Transparency disabled
1505  1676             //          : 1 : Transparency enabled
1506  1677   
1507  1678             func gfx_FrameDelay("milliseconds"), 0;         // 6  graphics animation frame delay
1508  1679             // Syntax   : gfx_FrameDelay("milliseconds");
1509  1680             // Usage    : gfx_FrameDelay(arg);
1510  1681             // Notes    : Sets the Video/Animation clip inter-frame delay for uSD_Video function.
1511  1682             //          : This setting will over-ride the embedded frame delay of the clip. After the event, the setting will autodisable, and
1512  1683             //          : if further inter-frame delays need overriding the setting must be reissued.
1513  1684             //          : This function will not control frame delays for a image control, refer to image control.
1514  1685             //          : value = 0 to 255 ms
1515  1686   
1516  1687             func gfx_ScreenMode("mode"), 0;                 // 7  graphics orientation LANDSCAPE, LANDSCAPE_R, PORTRAIT, PORTRAIT_R
1517  1688             // Usage    : gfx_ScreenMode(LANDSCAPE);
1518  1689             // Notes    : Set display orientation
1519  1690             //          : value = 1 : LANDSCAPE
1520  1691             //          : value = 2 : LANDSCAPE_R (Rotated)
1521  1692             //          : value = 3 : PORTRAIT
1522  1693             //          : value = 4 : PORTRAIT_R (Rotated)
1523  1694   
1524  1695             func gfx_OutlineColour("colour"), 0;            // 8  graphics rectangle/circle outline colour
1525  1696             // Syntax   : gfx_OutlineColour("colour");
1526  1697             // Usage    : gfx_OutlineColour(colr");
1527  1698             // Notes    : Sets the solid Rectangle or Circle objects outline colour.
1528  1699             //          : value = 0 : Disables this feature
1529  1700             //          : value = 1 to 0xFFFF : is the effective range
1530  1701   
1531  1702             func gfx_Contrast("value"), 0;                  // 9  graphics hardware contrast value 0-16 (0=off) *** only on internal driver devices
1532  1703             // Usage    : gfx_Contrast(val);
1533  1704             // Notes    : Set the display contrast
1534  1705             //          : 0 Display in low power mode. Display retains its contents in low power mode
1535  1706             //          : 1-16 Display on 1 = lowest, 16 = highest
1536  1707   
1537  1708             func gfx_LinePattern("value"), 0;               // 10 graphics line draw tesselation pattern (16 linear bits, 1=pixel off)
1538  1709             // Syntax   : gfx_LinePattern("value");
1539  1710             // Usage    : gfx_LinePattern(val);
1540  1711             // Notes    : Sets the line draw pattern for line drawing. If set to zero, lines are solid, else eac '1' bit represents
1541  1712             //          : a pixel that is turned off.
1542  1713             //          : 0 bits for pixels on
1543  1714             //          : 1 bits for pixels off
1544  1715   
1545  1716             func gfx_ColourMode("mode"), 0;                 // 11 graphics colour mode COLOUR8 or COLOUR16 (default colour 16)
1546  1717             // Syntax   : gfx_ColourMode("mode");
1547  1718             // Usage    : gfx_ColourMode(mod);
1548  1719             // Notes    : Set Graphics Colour mode
1549  1720             //          : COLOUR8  : 8bit colours
1550  1721             //          : COLOUR16 : 16bit colours
1551  1722   
1552  1723             //==============================================//
1553  1724             func _2C(), 0;                                  // 12 graphics  reserved
1554  1725             func _2D(), 0;                                  // 13 graphics  reserved
1555  1726             func _2E(), 0;                                  // 14 graphics  reserved
1556  1727             func _2F(), 0;                                  // 15 graphics  reserved
1557  1728             //==============================================//
1558  1729   
1559  1730   
1560  1731             //==============================================//
1561  1732             // generic constants                            //
1562  1733             //==============================================//
1563  1734             #CONST
1564  1741             #END
1565  1742   
1566  1743             //==============================================//
1567  1744             // joystick() function return constants         //
1568  1745             //==============================================//
1569  1746             #CONST
1570  1753             #END
1571  1754   
1572  1755             //==============================================//
1573  1756             // spi_Init(...)  mode arguments                //
1574  1757             //==============================================//
1575  1758             #CONST
1576  1768             #END
1577  1769   
1578  1770             //==============================================//
1579  1771             //Pin related constants                         //
1580  1772             //==============================================//
1581  1773             #CONST
1582  1784             #END
1583  1785   
1584  1786             //==============================================//
1585  1787             //gfx_Set() related constants                   //
1586  1788             //==============================================//
1587  1789             #CONST
1588  1802             #END
1589  1803   
1590  1804   
1591  1805             #CONST
1592  1816             #END
1593  1817   
1594  1818             //==============================================//
1595  1819             //txt_Set() related constants                   //
1596  1820             //==============================================//
1597  1821             #CONST
1598  1836             #END
1599  1837   
1600  1838             //==============================================//
1601  1839             //txt_Set() related arguments                   //
1602  1840             //==============================================//
1603  1841             #CONST
1604  1853             #END
1605  1854   
1606  1855   
1607  1856             //==============================================//
1608  1857             // Memory MAP                                   //
1609  1858             // system BYTE variables accesible with         //
1610  1859             // peekB and pokeB                              //
1611  1860             //==============================================//
1612  1861             #CONST
1613  1897             #END
1614  1898   
1615  1899   
1616  1900             //==============================================//
1617  1901             // system WORD variables accesible with peekW   //
1618  1902             // and pokeW or pointer access                  //
1619  1903             //==============================================//
1620  1904             #CONST
1621  1950             #END
1622  1951   
1623  1952             //==============================================//
1624  1953             // bit constants for SYS_FLAGS1                 //
1625  1954             //==============================================//
1626  1955             #CONST //SYS_FLAGS1
1627  1972             #END
1628  1973   
1629  1974             //==============================================//
1630  1975             // bit constants for SYS_FLAGS2                 //
1631  1976             //==============================================//
1632  1977             #CONST // SYS_FLAGS2
1633  1994             #END
1634  1995   
1635  1996   
1636  1997             //==============================================//
1637  1998             // EVE User Resources                           //
1638  1999             //==============================================//
1639  2000             #CONST
1640  2004             #END
1641  2005   
1642  2006             //------------------------------------------------------------------------------
1643  2007             //------------------------------------------------------------------------------
1644  2008             //------------------------------------------------------------------------------
1645  2009             //------------------------------------------------------------------------------
1646  2010             //------------------------------------------------------------------------------
1647  2011   
1648  2012   
1649  2013   
1650  2014   
1651  2015   
1652  2016   
1653  2017   
1654  2018   
1655  2019   
1656  2020   
1657  0002   
file C:\Program Files (x86)\4D Labs\4D Workshop 3 IDE\include\4DGL_16bitColours.fnc

1658  0003             #inherit "4DGL_16bitColours.fnc"
1659  0003             #inherit "4DGL_16bitColours.fnc"
1660  0004             */
1661  0005   
1662  0006   
1663  0007   
1664  0008             #CONST
1665  0149             #END
1666  0150   
file C:\Users\simon\Desktop\mugDisplay3\mugDisplay\mugDisplayUtils.fnc

1667  0004             #inherit "mugDisplayUtils.fnc"
1668  0004             #inherit "mugDisplayUtils.fnc"
1669  0001             var lastError := "";
1670  0002   
1671  0003             func setError(var err)
1672  0004                 lastError := err;
1673  0005             endfunc
1674  0006   
1675  0007             func getError()
1676  0008                 return lastError;
1677  0009             endfunc
file C:\Users\simon\Desktop\mugDisplay3\mugDisplay\mugDisplayCommunication.fnc

1678  0005             #inherit "mugDisplayCommunication.fnc"
1679  0005             #inherit "mugDisplayCommunication.fnc"
1680  0001             #constant SERIAL_BUFFER_SIZE    128
1681  0001             #constant SERIAL_BUFFER_SIZE    128
1682  0002             #constant MSG_BUFFER_SIZE       32
1683  0002             #constant MSG_BUFFER_SIZE       32
1684  0003   
1685  0004             var serial_buffer_ptr := 0;
1686  0005             var serial_buffer[SERIAL_BUFFER_SIZE];
1687  0006   
1688  0007             func getStringPtr()
1689  0008                 return serial_buffer + serial_buffer_ptr - 1;
1690  0009             endfunc
1691  0010   
1692  0011             func hasNextChar()
1693  0012                 if (com_Count() > 1) // ignore checksum (last byte)
1694  0013                     return TRUE;
1695  0014                 endif
1696  0015                 return FALSE;
1697  0016             endfunc
1698  0017   
1699  0018             func hasChars()
1700  0019                 return com_Count() - 1; // ignore checksum
1701  0020             endfunc
1702  0021   
1703  0022             func getNextChar()
1704  0023                 serial_buffer_ptr++;
1705  0024                 return serin();
1706  0025             endfunc
1707  0026   
1708  0027             func verifySerialBufferContents()
1709  0028                 var bytes;
1710  0029   
1711  0030                 bytes := com_Count();
1712  0031                 if (bytes <= 0)
1713  0032                     setError("Zero package");
1714  0033                     return FALSE;
1715  0034                 endif
1716  0035   
1717  0036                 if (com_Checksum())
1718  0037                     txt_MoveCursor(6, 0);
1719  0038                     setError("Checksum failed");
1720  0039                     return FALSE;
1721  0040                 endif
1722  0041   
1723  0042                 return TRUE;
1724  0043             endfunc
1725  0044   
1726  0045             func resetSerialBuffer()
1727  0046                 serial_buffer_ptr := 0;
1728  0047                 com_Init(serial_buffer, 0, '$');
1729  0048             endfunc
1730  0049   
1731  0050             func sendAck()
1732  0051                 to(COM0); print("OK\n");
1733  0052             endfunc
1734  0053   
1735  0054             func sendNAck(var errMsg)
1736  0055                 to(COM0); print("ERR:", [STR] errMsg, "\n");
1737  0056             endfunc
1738  0057   
1739  0058             func initCommunication(var baudrate)
1740  0059                 resetSerialBuffer();
1741  0060                 if (baudrate == 0)
1742  0061                     repeat
1743  0062                         baudrate := com_AutoBaud(500);
1744  0063                         txt_MoveCursor(2, 0);
1745  0064                         print("Waiting 'U'...");
1746  0065                     until (baudrate);
1747  0066                     print("\nOk");
1748  0067                     pause(500);
1749  0068                     gfx_Cls();
1750  0069                 else
1751  0070                     setbaud(baudrate);
1752  0071                 endif
1753  0072                 sendAck();
1754  0073             endfunc
file C:\Users\simon\Desktop\mugDisplay3\mugDisplay\mugDisplayDisplay.fnc

1755  0006             #inherit "mugDisplayDisplay.fnc"
1756  0006             #inherit "mugDisplayDisplay.fnc"
1757  0001             #constant scroll_blit_sector       $ 0x0020, 0x0000       /* offset 0xC400 */
1758  0001             #constant scroll_blit_sector       $ 0x0020, 0x0000       /* offset 0xC400 */
1759  0002             #constant selected_message_sector  $ 0x0010, 0x0000       /* offset selected message */
1760  0002             #constant selected_message_sector  $ 0x0010, 0x0000       /* offset selected message */
1761  0003   
1762  0004             #CONST
1763  0015             #END
1764  0016   
1765  0017   0007 var selection_area_properties[] := [0, 118, 127, 9, GREEN, BLACK, 15, 0, 1, 0];
1766  00071767  00081768  00091769  000A1770  000B1771  000C1772  000D1773  000E1774  000F1775  00101776  00111777  00121778  00131779  00141780  00151781  00161782  00171783  00181784  00191785  001A1786  0018   001B var message_window_properties[] := [0, 24, 127, 90, BLUE, BLACK, 13, 0, 0, 1];
1787  001B1788  001C1789  001D1790  001E1791  001F1792  00201793  00211794  00221795  00231796  00241797  00251798  00261799  00271800  00281801  00291802  002A1803  002B1804  002C1805  002D1806  002E1807  0019   002F var name_area_properties[] := [0, 0, 100, 9, GREEN, BLACK, 1, 0, 0, 0];
1808  002F1809  00301810  00311811  00321812  00331813  00341814  00351815  00361816  00371817  00381818  00391819  003A1820  003B1821  003C1822  003D1823  003E1824  003F1825  00401826  00411827  00421828  0020   0043 var power_icon_properties[] := [106, 2, ICON_WIDTH, ICON_HEIGHT, 0, BLACK];
1829  00431830  00441831  00451832  00461833  00471834  00481835  00491836  004A1837  004B1838  004C1839  004D1840  004E1841  0021   004F var signal_icon_properties[] := [62, 2, ICON_WIDTH, ICON_HEIGHT, 0, BLACK];
1842  004F1843  00501844  00511845  00521846  00531847  00541848  00551849  00561850  00571851  00581852  00591853  005A1854  0022   005B var transmission_icon_properties[] := [84, 2, ICON_WIDTH, ICON_HEIGHT, 0, BLACK];
1855  005B1856  005C1857  005D1858  005E1859  005F1860  00601861  00611862  00621863  00631864  00641865  00651866  00661867  0023   
1868  0024             var selected_message_buffer[MSG_BUFFER_SIZE];
1869  0025             var selected_message_length;
1870  0026             var selected_message;
1871  0027             var selected_message_offset;
1872  0028   
1873  0029             func displayIconAtPosition(var sectHi, var sectLo, var x, var y, var frame)
1874  0030                 media_SetSector(sectHi, sectLo);
1875  0031                 media_VideoFrame(x, y, frame);
1876  0032             endfunc
1877  0033   
1878  0034             func clearArea(var x, var y, var w, var h, var fg_colour, var bg_colour)
1879  0035                 var pixels;
1880  0036   
1881  0037                 gfx_Clipping(ON);
1882  0038                 gfx_ClipWindow(x, y, x+w, y+h);
1883  0039   
1884  0040                 pixels := gfx_FocusWindow();
1885  0041   
1886  0042                 disp_BlitPixelFill(bg_colour, pixels);
1887  0043                 gfx_Clipping(OFF);
1888  0044             endfunc
1889  0100             */
1890  0101   
1891  0102             func text_wrap(var str, var bfr, var offset)
1892  0103                 var txtStr, i, chars, width;
1893  0104                 var offsetCntr;
1894  0105                 var bfrPos;
1895  0106                 var lastDelimPos;
1896  0107                 var foundMoreChars := TRUE;
1897  0108                 var foundStart := FALSE;
1898  0109                 var twist := FALSE;
1899  0110                 var strStart, strEnd;
1900  0111   
1901  0112                 txtStr := str;
1902  0113                 chars := strlen(str);
1903  0114                 width := 0;
1904  0115                 lastDelimPos := 0;
1905  0116                 bfrPos:=0;
1906  0117                 offsetCntr:=0;
1907  0118   
1908  0119                 strStart := offset;
1909  0120                 strEnd := 0;
1910  0121   
1911  0122                 for (i:=0; i<chars; i++)
1912  0123                     var c;
1913  0124   
1914  0125                     c := txtStr[i] & 0x00ff;
1915  0126   
1916  0127                     if (offsetCntr >= offset)
1917  0128                         if (!foundStart)
1918  0129                              foundStart := TRUE;
1919  0130                         endif
1920  0131   
1921  0132                         if (c == '\n')
1922  0133                             offsetCntr++;
1923  0134                             break;
1924  0135                         else if ( c == '\0')
1925  0136                             foundMoreChars := FALSE;
1926  0137                             break;
1927  0138                         else
1928  0139                             if (!twist)
1929  0140                                 bfr[bfrPos] := c;
1930  0141                             else
1931  0142                                 bfr[bfrPos] |= (c << 8);
1932  0143                                 bfrPos++;
1933  0144                             endif
1934  0145                         endif
1935  0146                     endif
1936  0147   
1937  0148                     offsetCntr++;
1938  0149                     c := (txtStr[i] & 0xff00) >> 8;
1939  0150   
1940  0151                     if (offsetCntr >= offset)
1941  0152                         if (!foundStart)
1942  0153                              foundStart := TRUE;
1943  0154                              twist := TRUE;
1944  0155                         endif
1945  0156                         if (c == '\n')
1946  0157                             offsetCntr++;
1947  0158                             break;
1948  0159                         else if ( c == '\0')
1949  0160                             foundMoreChars := FALSE;
1950  0161                             break;
1951  0162                         else
1952  0163                             if (!twist)
1953  0164                                 bfr[bfrPos] |= (c << 8);
1954  0165                                 bfrPos++;
1955  0166                             else
1956  0167                                 bfr[bfrPos] := c;
1957  0168                             endif
1958  0169                         endif
1959  0170                     endif
1960  0171   
1961  0172                     offsetCntr++;
1962  0173                 next
1963  0174   
1964  0175                 if (foundMoreChars == FALSE)
1965  0176                     return 0;
1966  0177                 endif
1967  0178                 return offsetCntr;
1968  0179   
1969  0180             endfunc
1970  0181   
1971  0182             func print_message(var str, var area)
1972  0183                 var i, len;
1973  0184                 var found_delim;
1974  0185                 var found_name;
1975  0186   
1976  0187                 found_delim := FALSE;
1977  0188                 found_name := FALSE;
1978  0189   
1979  0190                 len := (strlen(str)+1) / 2;
1980  0191                 for (i:=0; i<len; i++)
1981  0192                     var c1, c2;
1982  0193   
1983  0194                     c1 := str[i] & 0x00ff;
1984  0195                     c2 := (str[i] & 0xff00) >> 8;
1985  0196   
1986  0197                     if (found_delim == FALSE)
1987  0198                         if (c2 == '/')
1988  0199                             found_delim := TRUE;
1989  0200                             found_name := TRUE;
1990  0201                             txt_FGcolour(RED);
1991  0202                             txt_Bold(1);
1992  0203                             continue;
1993  0204                         else if (c2 == '*')
1994  0205                             found_delim := TRUE;
1995  0206                             found_name := TRUE;
1996  0207                             txt_FGcolour(YELLOW);
1997  0208                             txt_Bold(1);
1998  0209                             continue;
1999  0210                         else if (c2 == '^')
2000  0211                             found_delim := TRUE;
2001  0212                             found_name := TRUE;
2002  0213                             txt_FGcolour(PURPLE);
2003  0214                             txt_Bold(1);
2004  0215                             continue;
2005  0216                         endif
2006  0217                     endif
2007  0218   
2008  0219                     if (found_name && c1 == ' ')
2009  0220                         txt_FGcolour(area[FG_COLOUR]);
2010  0221                         txt_Bold(area[TEXT_TYPE_BOLD]);
2011  0222                         found_name := FALSE;
2012  0223                     endif
2013  0224   
2014  0225                     if (i > 0 || c1 != ' ')
2015  0226                         putch(c1);
2016  0227                     endif
2017  0228   
2018  0229                     if (found_name && c2 == ' ')
2019  0230                         txt_FGcolour(area[FG_COLOUR]);
2020  0231                         txt_Bold(area[TEXT_TYPE_BOLD]);
2021  0232                         found_name := FALSE;
2022  0233                     endif
2023  0234   
2024  0235                     putch(c2);
2025  0236                 next
2026  0237             endfunc
2027  0238   
2028  0239             func display_text_in_area(var str, var area)
2029  0240                 var lines;
2030  0241                 var c1, c2;
2031  0242   
2032  0243                 clearArea(@area);
2033  0244   
2034  0245                 gfx_Clipping(ON);
2035  0246                 gfx_ClipWindow(area[X],
2036  0247                                area[Y],
2037  0248                                area[X] + area[WIDTH],
2038  0249                                area[Y] + area[HEIGHT]);
2039  0250   
2040  0251                 txt_MoveCursor(area[TEXT_LINE], area[TEXT_COL]);
2041  0252                 txt_Bold(area[TEXT_TYPE_BOLD]);
2042  0253                 txt_FGcolour(area[FG_COLOUR]);
2043  0254                 txt_BGcolour(area[BG_COLOUR]);
2044  0255   
2045  0256                 print_message(str, area);
2046  0257                 lines := 1;
2047  0258   
2048  0259                 gfx_Clipping(OFF);
2049  0260   
2050  0261                 return lines;
2051  0262             endfunc
2052  0263   
2053  0264             func scroll_text_in_selection_area()
2054  0265                 var private delay := 5;
2055  0266                 var len;
2056  0267   
2057  0268                 len := strlen(selected_message);
2058  0269   
2059  0270                 if (len < 17)
2060  0271                     return;
2061  0272                 endif
2062  0273   
2063  0274                 if (delay == 0)
2064  0275                     if (++selected_message_offset == len-1)
2065  0276                         selected_message_offset := 0;
2066  0277                         delay := 5;
2067  0278                     endif
2068  0279   
2069  0280                     if (selected_message_offset <= (strlen(selected_message) + 1) / 2)
2070  0281                         display_text_in_area(selected_message+selected_message_offset, selection_area_properties);
2071  0282                     endif
2072  0283                 else
2073  0284                     delay--;
2074  0285                 endif
2075  0286             endfunc
2076  0287   
2077  0288             func display_selection_text(var str, var offset)
2078  0289                 selected_message := str;
2079  0290                 selected_message_offset := offset;
2080  0291   
2081  0292                 if (selected_message_offset <= (strlen(selected_message) / 2) + 1)
2082  0293                     display_text_in_area(selected_message+selected_message_offset, selection_area_properties);
2083  0294                 endif
2084  0295             endfunc
2085  0296   
2086  0297             func display_selection_text_copy(var str, var offset)
2087  0298                 var len, i;
2088  0299   
2089  0300                 len := (strlen(str) + 1) / 2;
2090  0301   
2091  0302                 for (i:=0; i<MSG_BUFFER_SIZE; i++)
2092  0303                     if (i < len)
2093  0304                         selected_message_buffer[i] := str[i];
2094  0305                     else
2095  0306                         selected_message_buffer[i] := 0x00;
2096  0307                     endif
2097  0308                 next
2098  0309   
2099  0310                 display_selection_text(selected_message_buffer, offset);
2100  0311             endfunc
2101  0312   
2102  0313             func _write_str_to_window(var msg, var area)
2103  0314                 var pixels;
2104  0315                 var width, height;
2105  0316   
2106  0317                 if (msg[0] == 0x00)
2107  0318                     return;
2108  0319                 endif
2109  0320   
2110  0321                 width := strwidth(msg);
2111  0322                 height := strheight() + 3;
2112  0323   
2113  0324                 gfx_Clipping(ON);
2114  0325                 gfx_ClipWindow(area[X],
2115  0326                                area[Y] + height,
2116  0327                                area[X] + area[WIDTH],
2117  0328                                area[Y] + area[HEIGHT]);
2118  0329   
2119  0330                 gfx_FocusWindow();
2120  0331                 media_SetSector(scroll_blit_sector);
2121  0332                 pixels := disp_BlitPixelsToMedia();
2122  0333   
2123  0334                 display_text_in_area(msg, area);
2124  0335   
2125  0336                 gfx_ClipWindow(area[X],
2126  0337                                area[Y],
2127  0338                                area[X] + area[WIDTH],
2128  0339                                area[Y] + area[HEIGHT] - height);
2129  0340   
2130  0341                 pixels := gfx_FocusWindow();
2131  0342                 media_SetSector(scroll_blit_sector);
2132  0343                 disp_BlitPixelsFromMedia(pixels);
2133  0344                 gfx_Clipping(OFF);
2134  0345             endfunc
2135  0346   
2136  0347             func write_str_to_window(var str, var area)
2137  0348                 var lines;
2138  0349   
2139  0350                 if (area[TEXT_WRAP])
2140  0351                     var offset;
2141  0352   
2142  0353                     //offset := text_wrap(str, bfr, offset);
2143  0354   
2144  0355                     repeat
2145  0356                         var bfr[11];
2146  0357                         var i;
2147  0358   
2148  0359                         for (i:=0; i<11; i++)
2149  0360                             bfr[i] := 0;
2150  0361                         next
2151  0362   
2152  0363                         offset := text_wrap(str, bfr, offset);
2153  0364                         _write_str_to_window(bfr, area);
2154  0365                         lines++;
2155  0366                     until (offset == 0);
2156  0367   
2157  0368                 else
2158  0369                     lines := _write_str_to_window(str, area);
2159  0370                 endif
2160  0371   
2161  0372                 return lines;
2162  0373             endfunc
2163  0374   
2164  0375             func write_message(var str)
2165  0376                 write_str_to_window(str, message_window_properties);
2166  0377             endfunc
2167  0378   
2168  0379             func write_selected_message()
2169  0380                 write_str_to_window(selected_message, message_window_properties);
2170  0381                 //clearArea(@selection_area_properties);
2171  0382             endfunc
2172  0383   
2173  0384             func write_name(var str)
2174  0385                 txt_FGcolour(GREEN);
2175  0386                 txt_BGcolour(BLACK);
2176  0387                 txt_Bold(0);
2177  0388                 txt_Height(1);
2178  0389                 txt_Width(1);
2179  0390                 txt_MoveCursor(1, 0);
2180  0391                 print([STR]str);
2181  0392             endfunc
2182  0393   
2183  0394             func clear_message_area()
2184  0395                 clearArea(@message_window_properties);
2185  0396             endfunc
2186  0397   
2187  0398             func initScreenLayout()
2188  0399                 gfx_Hline(3+ICON_HEIGHT, 0, 127, GREEN);
2189  0400                 gfx_Hline(116, 0, 127, GREEN);
2190  0401                 clearArea(@message_window_properties);
2191  0402                 clearArea(@selection_area_properties);
2192  0403             endfunc
2193  0007             //==========================================================================
2194  0008   
2195  0009             #constant DISPLAY_SPLASH_SCREEN     := FALSE
2196  0009             #constant DISPLAY_SPLASH_SCREEN     := FALSE
2197  0010             #constant BAUD_AUTOBAUD             := 0
2198  0010             #constant BAUD_AUTOBAUD             := 0
2199  0011             #constant SERIAL_BAUDRATE           BAUD_19200
2200  0011             #constant SERIAL_BAUDRATE           BAUD_19200
2201  0012   
2202  0013             #constant ANIMATION_TIMEOUT         := 100
2203  0013             #constant ANIMATION_TIMEOUT         := 100
2204  0014             #constant TXT_SCROLL_TIMEOUT        := 350
2205  0014             #constant TXT_SCROLL_TIMEOUT        := 350
2206  0015             #constant SPLASH_SCREEN_DELAY       := 150
2207  0015             #constant SPLASH_SCREEN_DELAY       := 150
2208  0016             #constant ICON_WIDTH                := 20
2209  0016             #constant ICON_WIDTH                := 20
2210  0017             #constant ICON_HEIGHT               := 18
2211  0017             #constant ICON_HEIGHT               := 18
2212  0018   
2213  0019             #constant ANIMATION_TIMER           TIMER1
2214  0019             #constant ANIMATION_TIMER           TIMER1
2215  0020             #constant INIT_ANIMATION_TIMER      $ *ANIMATION_TIMER := ANIMATION_TIMEOUT
2216  0020             #constant INIT_ANIMATION_TIMER      $ *ANIMATION_TIMER := ANIMATION_TIMEOUT
2217  0021             #constant RESET_ANIMATION_TIMER     $ INIT_ANIMATION_TIMER
2218  0021             #constant RESET_ANIMATION_TIMER     $ INIT_ANIMATION_TIMER
2219  0022             #constant ANIMATION_TIMER_TIMEOUT   $ !(*ANIMATION_TIMER)
2220  0022             #constant ANIMATION_TIMER_TIMEOUT   $ !(*ANIMATION_TIMER)
2221  0023   
2222  0024             #constant TXT_SCROLL_TIMER           TIMER2
2223  0024             #constant TXT_SCROLL_TIMER           TIMER2
2224  0025             #constant INIT_TXT_SCROLL_TIMER      $ *TXT_SCROLL_TIMER := TXT_SCROLL_TIMEOUT
2225  0025             #constant INIT_TXT_SCROLL_TIMER      $ *TXT_SCROLL_TIMER := TXT_SCROLL_TIMEOUT
2226  0026             #constant RESET_TXT_SCROLL_TIMER     $ INIT_TXT_SCROLL_TIMER
2227  0026             #constant RESET_TXT_SCROLL_TIMER     $ INIT_TXT_SCROLL_TIMER
2228  0027             #constant TXT_SCROLL_TIMER_TIMEOUT   $ !(*TXT_SCROLL_TIMER)
2229  0027             #constant TXT_SCROLL_TIMER_TIMEOUT   $ !(*TXT_SCROLL_TIMER)
2230  0028   
2231  0029             #CONST
2232  0034             #END
2233  0035   
2234  0036             var _transmissionIconDisplayedState := 0;
2235  0037             var _transmissionIconFrame := 0;
2236  0038   
2237  0039             var _powerIconDisplayedState    := 0;
2238  0040             var _powerIconLevel             := 0;
2239  0041   
2240  0042             #CONST
2241  0050             #END
2242  0051   
2243  0052             var _signalIconDisplayedState    := 0;
2244  0053             var _signalIconLevel             := 0;
2245  0054   
2246  0055             #CONST
2247  0062             #END
2248  0063   
2249  0064             #CONST
2250  0068             #END
2251  0069   
2252  0070             #constant NUM_COMMANDS := 11
2253  0070             #constant NUM_COMMANDS := 11
2254  0082   0067                         display_name];
2255  00672256  00682257  00692258  006A2259  006B2260  006C2261  006D2262  006E2263  006F2264  00702265  00712266  00722267  00732268  00742269  00752270  00762271  00772272  00782273  00792274  007A2275  007B2276  007C2277  007D2278  007E2279  0083   
2280  0084   
2281  0085   
2282  0086             func checkArgCount(var count)
2283  0087                 if (hasChars() == count)
2284  0088                     return TRUE;
2285  0089                 endif
2286  0090                 return FALSE;
2287  0091             endfunc
2288  0092   
2289  0093             func showIcon(var icon, var show)
2290  0094                 if (icon == ICON_POWER)
2291  0095                     if (show)
2292  0096                         _powerIconDisplayedState := TRUE;
2293  0097                         displayIconAtPosition(power_icon_sector, power_icon_properties[X], power_icon_properties[Y], _powerIconLevel);
2294  0098                     else
2295  0099                         _powerIconDisplayedState := FALSE;
2296  0100                         clearArea(@power_icon_properties);
2297  0101                     endif
2298  0102                 else if (icon == ICON_SIGNAL)
2299  0103                     if (show)
2300  0104                         _signalIconDisplayedState := TRUE;
2301  0105                         displayIconAtPosition(signal_icon_sector, signal_icon_properties[X], signal_icon_properties[Y], _signalIconLevel);
2302  0106                     else
2303  0107                         _signalIconDisplayedState := FALSE;
2304  0108                         clearArea(@signal_icon_properties);
2305  0109                     endif
2306  0110                 else if (icon == ICON_TRANSMISSION)
2307  0111                     if (show)
2308  0112                         _transmissionIconFrame := 0;
2309  0113                         _transmissionIconDisplayedState := TRUE;
2310  0114                     else
2311  0115                         _transmissionIconDisplayedState := FALSE;
2312  0116                         clearArea(@transmission_icon_properties);
2313  0117                     endif
2314  0118                 else
2315  0119                     setError("Unknown icon");
2316  0120                     return FALSE;
2317  0121                 endif
2318  0122   
2319  0123                 return TRUE;
2320  0124             endfunc
2321  0125   
2322  0126             func set_signal_level_parser()
2323  0127                 var level;
2324  0128   
2325  0129                 if (!checkArgCount(1))
2326  0130                     setError("Wrong arg count");
2327  0131                     return FALSE;
2328  0132                 endif
2329  0133   
2330  0134                 level := getNextChar();
2331  0135   
2332  0136                 if (level < 0 || level >= signal_icon_max_idx)
2333  0137                     setError("Invalid parameter");
2334  0138                     return FALSE;
2335  0139                 endif
2336  0140   
2337  0141                 _signalIconLevel := level;
2338  0142                 return showIcon(ICON_SIGNAL, _signalIconDisplayedState);
2339  0143             endfunc
2340  0144   
2341  0145             func set_power_level_parser()
2342  0146                 var level;
2343  0147   
2344  0148                 if (!checkArgCount(1))
2345  0149                     setError("Wrong arg count");
2346  0150                     return FALSE;
2347  0151                 endif
2348  0152   
2349  0153                 level := getNextChar();
2350  0154   
2351  0155                 if (level < 0 || level >= power_icon_max_idx)
2352  0156                     setError("Invalid parameter");
2353  0157                     return FALSE;
2354  0158                 endif
2355  0159   
2356  0160                 _powerIconLevel := level;
2357  0161                 return showIcon(ICON_POWER, _powerIconDisplayedState);
2358  0162             endfunc
2359  0163   
2360  0164             func show_token_parser()
2361  0165                 var icon;
2362  0166                 var show;
2363  0167   
2364  0168                 if (!checkArgCount(2))
2365  0169                     setError("Wrong arg count");
2366  0170                     return FALSE;
2367  0171                 endif
2368  0172   
2369  0173                 icon := getNextChar();
2370  0174                 show := getNextChar();
2371  0175   
2372  0176                 return showIcon(icon, show);
2373  0177             endfunc
2374  0178   
2375  0179             func display_selected_message_parser()
2376  0180                 display_selection_text_copy(getStringPtr(), 0);
2377  0181                 return TRUE;
2378  0182             endfunc
2379  0183   
2380  0184             func write_selected_message_parser()
2381  0185                  write_selected_message();
2382  0186                  return TRUE;
2383  0187             endfunc
2384  0188   
2385  0189             func write_message_parser()
2386  0190                 write_message(getStringPtr());
2387  0191                 return TRUE;
2388  0192             endfunc
2389  0193   
2390  0194             func set_contrast_parser()
2391  0195                 var level;
2392  0196   
2393  0197                 if (!checkArgCount(1))
2394  0198                     setError("Wrong arg count");
2395  0199                     return FALSE;
2396  0200                 endif
2397  0201   
2398  0202                 level := getNextChar();
2399  0203   
2400  0204                 if (level < 0 || level > 16)
2401  0205                     setError("Invalid parameter");
2402  0206                     return FALSE;
2403  0207                 endif
2404  0208   
2405  0209                 gfx_Contrast(level);
2406  0210                 return TRUE;
2407  0211             endfunc
2408  0212   
2409  0213             func clear_msg_area()
2410  0214                  clear_message_area();
2411  0215                  return TRUE;
2412  0216             endfunc
2413  0217   
2414  0218             func display_name()
2415  0219                 write_name(getStringPtr());
2416  0220                 return TRUE;
2417  0221             endfunc
2418  0222   
2419  0223             func parseSerialBuffer()
2420  0224                 var cmd;
2421  0225                 var cntr;
2422  0226                 var retval;
2423  0227   
2424  0228                 cntr := 0;
2425  0229   
2426  0230                 if (!hasNextChar())
2427  0231                     setError("No command");
2428  0232                     return FALSE;
2429  0233                 endif
2430  0234   
2431  0235                 cmd := getNextChar();
2432  0236                 if (cmd == 0 || cmd > NUM_COMMANDS)
2433  0237                     setError("Unknown command");
2434  0238                     return FALSE;
2435  0239                 endif
2436  0240   
2437  0241                 retval := tokenParsers[cmd]();
2438  0242                 return retval;
2439  0243             endfunc
2440  0244   
2441  0245             func waitForMedia()
2442  0246                 gfx_Cls();
2443  0247                 while (media_Init() == 0)                           // initialise and test the uSD card
2444  0248                     txt_FGcolour(RED);
2445  0249                     print("Insert uSD card");
2446  0250                     pause(2000);
2447  0251                     gfx_Cls();
2448  0252                 wend
2449  0253             endfunc
2450  0254   
2451  0255             func main()
2452  0256                 waitForMedia();
2453  0257                 initScreenLayout();
2454  0258                 initCommunication(SERIAL_BAUDRATE);
2455  0259                 INIT_ANIMATION_TIMER;
2456  0260                 INIT_TXT_SCROLL_TIMER;
2457  0261   
2458  0262                // pause(500);
2459  0263   
2460  0264                 repeat
2461  0265                     if (com_Error())
2462  0266                         resetSerialBuffer();
2463  0267                         sendNAck("COM_ERROR");
2464  0268                     endif
2465  0269   
2466  0270                     if (com_Full())
2467  0271                         if (verifySerialBufferContents())
2468  0272                             if(parseSerialBuffer())
2469  0273                                 sendAck();
2470  0274                             else
2471  0275                                 sendNAck(getError());
2472  0276                             endif
2473  0277                         else
2474  0278                             sendNAck(getError());
2475  0279                         endif
2476  0280                         resetSerialBuffer();
2477  0281                     endif
2478  0282   
2479  0283                     if (ANIMATION_TIMER_TIMEOUT)
2480  0284                         if (_transmissionIconDisplayedState)
2481  0285                             media_SetSector(transmission_icon_sector);
2482  0286                             media_VideoFrame(transmission_icon_properties[X],transmission_icon_properties[Y], _transmissionIconFrame++);
2483  0287                             _transmissionIconFrame := _transmissionIconFrame % 11;
2484  0288                         endif
2485  0289                         RESET_ANIMATION_TIMER;
2486  0290                     endif
2487  0291   
2488  0292                     if (TXT_SCROLL_TIMER_TIMEOUT)
2489  0293                         scroll_text_in_selection_area();
2490  0294                         RESET_TXT_SCROLL_TIMER;
2491  0295                     endif
2492  0296                 forever
2493  0297             endfunc
2494  0298   
Notice: Check that the function called via pointer array 'tokenParsers' requires 0 arguments (line 241 file:mugDisplay.4DG)
Notice: variable 'area' is being indexed (line 350 file:mugDisplayDisplay.fnc)
Notice: variable 'msg' is being indexed (line 317 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 325 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 326 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 327 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 327 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 328 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 328 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 336 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 337 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 338 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 338 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 339 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 339 file:mugDisplayDisplay.fnc)
Notice: variable 'str' is being indexed (line 304 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 246 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 247 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 248 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 248 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 249 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 249 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 251 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 251 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 252 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 253 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 254 file:mugDisplayDisplay.fnc)
Notice: local var 'c2' in func 'display_text_in_area' is never used (line 241 file:mugDisplayDisplay.fnc)
Notice: local var 'c1' in func 'display_text_in_area' is never used (line 241 file:mugDisplayDisplay.fnc)
Notice: variable 'str' is being indexed (line 194 file:mugDisplayDisplay.fnc)
Notice: variable 'str' is being indexed (line 195 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 220 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 221 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 230 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 231 file:mugDisplayDisplay.fnc)
Notice: variable 'txtStr' is being indexed (line 125 file:mugDisplayDisplay.fnc)
Notice: variable 'bfr' is being indexed (line 140 file:mugDisplayDisplay.fnc)
Notice: variable 'bfr' is being indexed (line 142 file:mugDisplayDisplay.fnc)
Notice: variable 'txtStr' is being indexed (line 149 file:mugDisplayDisplay.fnc)
Notice: variable 'bfr' is being indexed (line 164 file:mugDisplayDisplay.fnc)
Notice: variable 'bfr' is being indexed (line 167 file:mugDisplayDisplay.fnc)
Notice: function argument 'fg_colour' in func 'clearArea' is never used (line 34 file:mugDisplayDisplay.fnc)


Symbol Table:
name                 decimal    hex
__MAXMEM                             255  0x000000ff (const dword)  (usage 1)
__MAXPROG                           9216  0x00002400 (const dword)  (usage 1)
_powerIconDisplayedState             432  0x000001b0 (mem) word (global)  (usage 4)
_powerIconLevel                      434  0x000001b2 (mem) word (global)  (usage 3)
_signalIconDisplayedState            436  0x000001b4 (mem) word (global)  (usage 4)
_signalIconLevel                     438  0x000001b6 (mem) word (global)  (usage 3)
_transmissionIconDisplayedState      428  0x000001ac (mem) word (global)  (usage 4)
_transmissionIconFrame               430  0x000001ae (mem) word (global)  (usage 5)
_write_str_to_window                1560  0x00000618 (User func) args[2] r=0  (usage 2)
ANIMATION_TIMEOUT                    100  0x00000064 (const dword)  (usage 2)
ANIMATION_TIMER                      115  0x00000073 (const dword)  (usage 3)
ANIMATION_TIMER_TIMEOUT           7369880  0x00707498(macro)  !(*ANIMATION_TIMER)   (usage 1)
BAUD_19200                           155  0x0000009b (const dword)  (usage 1)
BG_COLOUR                              5  0x00000005 (const ??? 0)  (usage 1)
BLACK                                  0  0x00000000 (const dword)  (usage 7)
BLUE                                  31  0x0000001f (const dword)  (usage 1)
checkArgCount                       1279  0x000004ff (User func) args[1] r=0  (usage 4)
clear_message_area                  1356  0x0000054c (User func) args[0] r=0  (usage 1)
clear_msg_area                       640  0x00000280 (User func) args[0] r=0  (usage 1)
clearArea                           2845  0x00000b1d (User func) args[6] r=0  (usage 7)
COM0                               65284  0x0000ff04 (const dword)  (usage 2)
com_AutoBaud                         -86  0xffffffaa (PmmC func) args[1] r=1  (usage 1)
com_Checksum                         -93  0xffffffa3 (PmmC func) args[0] r=1  (usage 1)
com_Count                            -89  0xffffffa7 (PmmC func) args[0] r=1  (usage 3)
com_Error                            -91  0xffffffa5 (PmmC func) args[0] r=1  (usage 1)
com_Full                             -90  0xffffffa6 (PmmC func) args[0] r=1  (usage 1)
com_Init                             -87  0xffffffa9 (PmmC func) args[3] r=0  (usage 1)
delay                             UNRESOLVED  (usage 3)
disp_BlitPixelFill                  -101  0xffffff9b (PmmC func) args[2] r=0  (usage 1)
disp_BlitPixelsFromMedia            -105  0xffffff97 (PmmC func) args[1] r=0  (usage 1)
disp_BlitPixelsToMedia              -102  0xffffff9a (PmmC func) args[0] r=1  (usage 1)
display_name                         626  0x00000272 (User func) args[0] r=0  (usage 1)
display_selected_message_parser      778  0x0000030a (User func) args[0] r=0  (usage 1)
display_selection_text              1860  0x00000744 (User func) args[2] r=0  (usage 1)
display_selection_text_copy         1769  0x000006e9 (User func) args[2] r=0  (usage 1)
display_text_in_area                1997  0x000007cd (User func) args[2] r=0  (usage 3)
displayIconAtPosition               2901  0x00000b55 (User func) args[5] r=0  (usage 2)
FALSE                                  0  0x00000000 (const dword)  (usage 34)
FG_COLOUR                              4  0x00000004 (const ??? 0)  (usage 3)
getError                            3257  0x00000cb9 (User func) args[0] r=0  (usage 2)
getNextChar                         3212  0x00000c8c (User func) args[0] r=0  (usage 6)
getStringPtr                        3248  0x00000cb0 (User func) args[0] r=0  (usage 3)
gfx_Clipping                        -148  0xffffff6c (PmmC func) args[1] r=0  (usage 6)
gfx_ClipWindow                       -65  0xffffffbf (PmmC func) args[4] r=0  (usage 4)
gfx_Cls                              -41  0xffffffd7 (PmmC func) args[0] r=0  (usage 3)
gfx_Contrast                        -154  0xffffff66 (PmmC func) args[1] r=0  (usage 1)
gfx_FocusWindow                      -67  0xffffffbd (PmmC func) args[0] r=1  (usage 3)
gfx_Hline                            -47  0xffffffd1 (PmmC func) args[4] r=1  (usage 2)
GOLDELOX                               1  0x00000001 (const dword)  (usage 1)
GREEN                               1024  0x00000400 (const dword)  (usage 5)
hasChars                            3222  0x00000c96 (User func) args[0] r=0  (usage 1)
hasNextChar                         3231  0x00000c9f (User func) args[0] r=0  (usage 1)
HEIGHT                                 3  0x00000003 (const ??? 0)  (usage 3)
ICON_HEIGHT                           18  0x00000012 (const dword)  (usage 4)
ICON_POWER                             1  0x00000001 (const dword)  (usage 2)
ICON_SIGNAL                            2  0x00000002 (const dword)  (usage 2)
ICON_TRANSMISSION                      3  0x00000003 (const dword)  (usage 1)
ICON_WIDTH                            20  0x00000014 (const dword)  (usage 3)
INIT_ANIMATION_TIMER              7374224  0x00708590(macro)  *ANIMATION_TIMER := ANIMATION_TIMEOUT   (usage 2)
INIT_TXT_SCROLL_TIMER             7374272  0x007085c0(macro)  *TXT_SCROLL_TIMER := TXT_SCROLL_TIMEOUT   (usage 2)
initCommunication                   2924  0x00000b6c (User func) args[1] r=0  (usage 1)
initScreenLayout                    1296  0x00000510 (User func) args[0] r=0  (usage 1)
lastError                              0  0x00000000 (mem) word (global)  (usage 3)
media_Init                           -79  0xffffffb1 (PmmC func) args[0] r=1  (usage 1)
media_SetSector                      -72  0xffffffb8 (PmmC func) args[2] r=0  (usage 4)
media_VideoFrame                     -70  0xffffffba (PmmC func) args[3] r=0  (usage 2)
message_window_properties            280  0x00000118 (mem) word[10] (global)  (usage 4)
MSG_BUFFER_SIZE                       32  0x00000020 (const dword)  (usage 2)
NUM_COMMANDS                          11  0x0000000b (const dword)  (usage 1)
OFF                                    0  0x00000000 (const dword)  (usage 3)
ON                                     1  0x00000001 (const dword)  (usage 3)
parseSerialBuffer                    519  0x00000207 (User func) args[0] r=0  (usage 1)
pause                                 -6  0xfffffffa (PmmC func) args[1] r=0  (usage 2)
power_icon_max_idx                     6  0x00000006 (const ??? 0)  (usage 1)
power_icon_properties                320  0x00000140 (mem) word[6] (global)  (usage 3)
power_icon_sector                 7374328  0x007085f8(macro)  0x0000, 0x0000   (usage 1)
print_message                       2143  0x0000085f (User func) args[2] r=0  (usage 1)
PURPLE                             32784  0x00008010 (const dword)  (usage 1)
putch                                 -2  0xfffffffe (PmmC func) args[1] r=0  (usage 2)
RED                                63488  0x0000f800 (const dword)  (usage 2)
RESET_ANIMATION_TIMER             7369848  0x00707478(macro)  INIT_ANIMATION_TIMER   (usage 1)
RESET_TXT_SCROLL_TIMER            7369912  0x007074b8(macro)  INIT_TXT_SCROLL_TIMER   (usage 1)
resetSerialBuffer                   3104  0x00000c20 (User func) args[0] r=0  (usage 3)
scroll_blit_sector                7441320  0x00718ba8(macro)  0x0020, 0x0000       /* offset 0xC400 */   (usage 2)
scroll_text_in_selection_area       1905  0x00000771 (User func) args[0] r=0  (usage 1)
scroll_text_in_selection_area.delay     426  0x000001aa (mem) word (member of scroll_text_in_selection_area)  (usage 2)
selected_message                     422  0x000001a6 (mem) word (global)  (usage 7)
selected_message_buffer              356  0x00000164 (mem) word[32] (global)  (usage 3)
selected_message_offset              424  0x000001a8 (mem) word (global)  (usage 7)
selection_area_properties            260  0x00000104 (mem) word[10] (global)  (usage 3)
sendAck                             3080  0x00000c08 (User func) args[0] r=0  (usage 2)
sendNAck                            3037  0x00000bdd (User func) args[1] r=0  (usage 3)
SERIAL_BAUDRATE                      155  0x0000009b (const dword)  (usage 1)
serial_buffer                          4  0x00000004 (mem) word[128] (global)  (usage 2)
serial_buffer_ptr                      2  0x00000002 (mem) word (global)  (usage 4)
SERIAL_BUFFER_SIZE                   128  0x00000080 (const dword)  (usage 1)
serin                                 -1  0xffffffff (PmmC func) args[0] r=1  (usage 1)
set_contrast_parser                  649  0x00000289 (User func) args[0] r=0  (usage 1)
set_power_level_parser               860  0x0000035c (User func) args[0] r=0  (usage 1)
set_signal_level_parser              971  0x000003cb (User func) args[0] r=0  (usage 1)
setbaud                               -4  0xfffffffc (PmmC func) args[1] r=0  (usage 1)
setError                            3260  0x00000cbc (User func) args[1] r=0  (usage 12)
show_token_parser                    794  0x0000031a (User func) args[0] r=0  (usage 1)
showIcon                            1082  0x0000043a (User func) args[2] r=0  (usage 3)
signal_icon_max_idx                    5  0x00000005 (const ??? 0)  (usage 1)
signal_icon_properties               332  0x0000014c (mem) word[6] (global)  (usage 3)
signal_icon_sector                7374352  0x00708610(macro)  0x0000, 0x0009   (usage 1)
STR                                  128  0x00000080 (const dword)  (usage 2)
strheight                           -127  0xffffff81 (PmmC func) args[0] r=1  (usage 1)
strlen                              -123  0xffffff85 (PmmC func) args[1] r=1  (usage 6)
strwidth                            -126  0xffffff82 (PmmC func) args[1] r=1  (usage 1)
TEXT_COL                               7  0x00000007 (const ??? 0)  (usage 1)
TEXT_LINE                              6  0x00000006 (const ??? 0)  (usage 1)
TEXT_TYPE_BOLD                         8  0x00000008 (const ??? 0)  (usage 3)
text_wrap                           2494  0x000009be (User func) args[3] r=0  (usage 1)
TEXT_WRAP                              9  0x00000009 (const ??? 0)  (usage 1)
TIMER1                               115  0x00000073 (const dword)  (usage 1)
TIMER2                               116  0x00000074 (const dword)  (usage 1)
to                                    -5  0xfffffffb (PmmC func) args[1] r=1  (usage 2)
tokenParsers                         440  0x000001b8 (mem) word[12] (global)  (usage 1)
transmission_icon_properties         344  0x00000158 (mem) word[6] (global)  (usage 3)
transmission_icon_sector          7374376  0x00708628(macro)  0x0000, 0x0011   (usage 1)
TRUE                                   1  0x00000001 (const dword)  (usage 26)
txt_BGcolour                        -130  0xffffff7e (PmmC func) args[1] r=0  (usage 2)
txt_Bold                            -138  0xffffff76 (PmmC func) args[1] r=0  (usage 7)
txt_FGcolour                        -129  0xffffff7f (PmmC func) args[1] r=0  (usage 8)
txt_Height                          -133  0xffffff7b (PmmC func) args[1] r=0  (usage 1)
txt_MoveCursor                       -28  0xffffffe4 (PmmC func) args[2] r=0  (usage 4)
TXT_SCROLL_TIMEOUT                   350  0x0000015e (const dword)  (usage 2)
TXT_SCROLL_TIMER                     116  0x00000074 (const dword)  (usage 3)
TXT_SCROLL_TIMER_TIMEOUT          7369944  0x007074d8(macro)  !(*TXT_SCROLL_TIMER)   (usage 1)
txt_Width                           -132  0xffffff7c (PmmC func) args[1] r=0  (usage 1)
verifySerialBufferContents          3123  0x00000c33 (User func) args[0] r=0  (usage 1)
waitForMedia                         448  0x000001c0 (User func) args[0] r=0  (usage 1)
WIDTH                                  2  0x00000002 (const ??? 0)  (usage 3)
write_message                       1443  0x000005a3 (User func) args[1] r=0  (usage 1)
write_message_parser                 755  0x000002f3 (User func) args[0] r=0  (usage 1)
write_name                          1370  0x0000055a (User func) args[1] r=0  (usage 1)
write_selected_message              1432  0x00000598 (User func) args[0] r=0  (usage 1)
write_selected_message_parser        769  0x00000301 (User func) args[0] r=0  (usage 1)
write_str_to_window                 1454  0x000005ae (User func) args[2] r=0  (usage 2)
X                                      0  0x00000000 (const dword)  (usage 9)
Y                                      1  0x00000001 (const ??? 0)  (usage 9)
YELLOW                             65504  0x0000ffe0 (const dword)  (usage 1)
