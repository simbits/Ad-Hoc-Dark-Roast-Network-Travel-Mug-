4DGL Compiler 2.6.0.4 -- Copyright 2004-2010 4D Labs
** C:\Documents and Settings\simon\Bureaublad\mugDisplay\mugDisplay\mugDisplay.4DG compiled Mon Apr 18 15:58:42 2011

file C:\Documents and Settings\simon\Bureaublad\mugDisplay\mugDisplay\mugDisplay.4DG

file C:\Program Files\4D Labs\4D Workshop 3 IDE\include\GOLDELOX-GFX2.fnc

0001  0001             #platform "GOLDELOX-GFX2"
0002  0001             #platform "GOLDELOX-GFX2"
0003  0007             */
0004  0010             */
0005  0011   
0006  0012                 // for Goldelox GFX2
0007  0013   
0008  0014                 #constant GOLDELOX      1
0009  0014                 #constant GOLDELOX      1
0010  0015   
0011  0016                 #constant __MAXMEM      255
0012  0016                 #constant __MAXMEM      255
0013  0017                 #constant __MAXPROG     9216
0014  0017                 #constant __MAXPROG     9216
0015  0018   
0016  0019                 #constant __PLATFORM    GOLDELOX
0017  0019                 #constant __PLATFORM    GOLDELOX
0018  0020   
0019  0021   
0020  0022   
0021  0023   
0022  0024             //==============================================//
0023  0025             // initialization table additional commands     //
0024  0026             //==============================================//
0025  0027             #CONST
0026  0037             #END
0027  0038   
0028  0039             //==============================================//
0029  0040             // putch, putstr, putnum and print redirection  //
0030  0041             // constants                                    //
0031  0042             //==============================================//
0032  0043             #CONST
0033  0048             #END
0034  0049   
0035  0050             //==============================================//
0036  0051             // general number formatting constants          //
0037  0052             // for 'print' and 'putnum'                     //
0038  0053             //==============================================//
0039  0054             #CONST
0040  0186             #END
0041  0187   
0042  0188             // baud divisor rates
0043  0189             #CONST
0044  0211             #END
0045  0212   
0046  0213   
0047  0214   
0048  0219             */
0049  0220   
0050  0221   
0051  0222             //==============================================//
0052  0223             // EVE bios functions                           //
0053  0224             //==============================================//
0054  0225   
0055  0226             func serin(), 1;                                // read a byte from COM0
0056  0227             // Syntax   : serin();
0057  0228             // Usage    : char := serin();
0058  0229             // Notes    : Receives a character from the Serial Port COM0. The transmission format is:
0059  0230             //          : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
0060  0231             //          : The default Baud Rate is 115,200 bits per second or 115,200 baud. The baud rate can be
0061  0232             //          : changed under program control by using the setbaud(...) function.
0062  0233             //          : Returns: -1 if no character is available
0063  0234             //          : Returns: -2 if a framing error or over-run has occurred (auto cleared)
0064  0235             //          : Returns: positive value 0 to 255 for a valid character received
0065  0236   
0066  0237             func putch("char"), 0;                          // write single char to current output device
0067  0238             // Syntax   : putch("char");
0068  0239             // Usage    : putch("A");
0069  0240             // Notes    : Transmits a single byte from the Serial Port COM0. The transmission format is:
0070  0241             //          : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
0071  0242             //          : The default Baud Rate is 115,200 bits per second or 115,200 baud. The baud rate can be
0072  0243             //          : changed under program control by using the setbaud(...) function.
0073  0244             //          : The arguments can be a variable, array element, expression or constant
0074  0245   
0075  0246             func serout("char"), 0;                         // write a byte to COM0
0076  0247             // Syntax   : serout1("char");
0077  0248             // Usage    : serout1(ch);
0078  0249             // Notes    : send character to COM1
0079  0250   
0080  0251             func setbaud("baudnum"), 0;                     // set baud rate of COM0
0081  0252             // Syntax   : setbaud(baud_number);
0082  0253             // Usage    : setbaud(BAUD_128000);        //Set baud rate to 128000bps
0083  0254             // Notes   : specifies the baud rate divisor value or pre-defined constant
0084  0255             //          : The arguments can be a variable, array element, expression or constant
0085  0256             //          : Baud Number Divisor
0086  0257             //          : BAUD_110    27271
0087  0258             //          : BAUD_300    9999
0088  0259             //          : BAUD_600    4999
0089  0260             //          : BAUD_1200   2499
0090  0261             //          : BAUD_2400   1249
0091  0262             //          : BAUD_4800   624
0092  0263             //          : BAUD_9600   312
0093  0264             //          : BAUD_14400  207
0094  0265             //          : BAUD_19200  155
0095  0266             //          : BAUD_31250  95
0096  0267             //          : BAUD_38400  77
0097  0268             //          : BAUD_56000  53
0098  0269             //          : BAUD_57600  51
0099  0270             //          : BAUD_115200 25
0100  0271             //          : BAUD_128000 22
0101  0272             //          : BAUD_256000 11
0102  0273             //          : BAUD_300000 10
0103  0274             //          : BAUD_375000 8
0104  0275             //          : BAUD_500000 6
0105  0276             //          : BAUD_600000 4
0106  0277             //          :
0107  0278             //          : The baud rate is calculated with the following formula:
0108  0279             //          : rate-divisor = (3000000 / baud ) - 1
0109  0280   
0110  0281             func to("device"), 1;                           // output device redirection
0111  0282             // Syntax   : to(outstream);
0112  0283             // Usage    : to(APPEND); putstr("TWO ");
0113  0284             // Notes    : outstream: A variable or constant specifying destination for putch, putstr, putnum and print functions.
0114  0285             //          :
0115  0286             //          : to() sends the printed output to destinations other than the screen. Normally, print just
0116  0287             //          : sends its output to the display in TEXT mode which is the default, however, the output from
0117  0288             //          : print can be sent to COM0, and MDA (media) 'streams'. The to(...) function can also stream
0118  0289             //          : to a memory array . Note that once the to(...) function has taken effect, the stream reverts
0119  0290             //          : back to the default stream which is TEXT as soon as putch, putstr, putnum or print has
0120  0291             //          : completed its action. The APPEND argument is used to send the printed output to the same
0121  0292             //          : place as the previous redirection. This is most useful for building string arrays, or adding
0122  0293             //          : sequential data to a media stream.
0123  0294             //          :
0124  0295             //          : Predefined Name   Constant    putch(), putstr(), putnum(), print() redirection
0125  0296             //          : APPEND            0x0000          Output is directed to the same stream that was previously assigned. Output is
0126  0297             //          :                                   appended to user array if previous redirection was to an array.
0127  0298             //          : COM0              0xFF04          Output is redirected to the COM (serial) port.
0128  0299             //          : TEXT              0xFF08          Output is directed to the screen (default).
0129  0300             //          : MDA               0xFF10          Output is directed to the SD or FLASH media.
0130  0301             //          : memory pointer    0x102<0x3FF     Output is redirect to the memory pointer argument.
0131  0302   
0132  0303             func pause("milliseconds"), 0;                  // blocking delay
0133  0304             // Syntax   : pause(milliseconds);
0134  0305             // Usage    : pause(1000);                      //pause for 1 second
0135  0306             // Notes    : Pause for a number of milli second.Maximum delay could be 65535 milli seconds
0136  0307   
0137  0308             func putnum("arg1","arg2"), 1;                  // print number to current output device
0138  0309             // Syntax   : putnum(format, value);
0139  0310             // Usage    : var := putnum(HEX, val);
0140  0311             // Notes    : prints a 16bit number in various formats to the current output stream, usually the display.
0141  0312             //          : Format: A constant that specifies the number format
0142  0313             //          : Value : The number to be printed
0143  0314             //          : (      DECIMAL   )    (   UNSIGNED DECIMAL )    (    HEX         )    (    BINARY          )
0144  0315             //          : DEC  DECZ  DECZB      UDEC  UDECZ  UDECZB       HEX  HEXZ  HEXZB      BIN  BINZ    BINZB
0145  0316             //          : DEC1 DEC1Z DEC1ZB     UDEC1 UDEC1Z UDEC1ZB      HEX1 HEX1Z HEX1ZB     BIN1  BIN1Z   BIN1ZB
0146  0317             //          : DEC2 DEC2Z DEC2ZB     UDEC2 UDEC2Z UDEC2ZB      HEX2 HEX2Z HEX1ZB     BIN2  BIN2Z   BIN2ZB
0147  0318             //          : DEC3 DEC3Z DEC3ZB     UDEC3 UDEC3Z UDEC3ZB      HEX3 HEX3Z HEX1ZB     BIN3  BIN3Z   BIN3ZB
0148  0319             //          : DEC4 DEC4Z DEC4ZB     UDEC4 UDEC4Z UDEC4ZB      HEX4 HEX4Z HEX1ZB     BIN4  BIN4Z   BIN4ZB
0149  0320             //          : DEC5 DEC5Z DEC5ZB     UDEC5 UDEC5Z UDEC5ZB                            BIN5  BIN5Z   BIN5ZB
0150  0321             //          :                                                                       BIN6  BIN6Z   BIN6ZB
0151  0322             //          :                                                                       BIN7  BIN7Z   BIN7ZB
0152  0323             //          :                                                                       BIN8  BIN8Z   BIN8ZB
0153  0324             //          :                                                                       BIN9  BIN9Z   BIN9ZB
0154  0325             //          :                                                                       BIN10 BIN10Z  BIN10ZB
0155  0326             //          :                                                                       BIN11 BIN11Z  BIN11ZB
0156  0327             //          :                                                                       BIN12 BIN12Z  BIN12ZB
0157  0328             //          :                                                                       BIN13 BIN13Z  BIN13ZB
0158  0329             //          :                                                                       BIN14 BIN14Z  BIN14ZB
0159  0330             //          :                                                                       BIN15 BIN15Z  BIN15ZB
0160  0331             //          :                                                                       BIN16 BIN16Z  BIN16ZB
0161  0332             //          :
0162  0333             //          : field: Returns the the default width of the numeric field (digit count), usually ignored.
0163  0334             //          :============================================================================
0164  0335             //          : number formatting bits
0165  0336             //          :============================================================================
0166  0337             //          : bit 15 14 13 12 11 10 9  8  7  6  5  4  3  2  1  0
0167  0338             //          :     |  |  |  |   \___ ___/  |  \  /  \_____ _____/
0168  0339             //          :     |  |  |  |       V      |   V          V
0169  0340             //          :     |  |  |  |       |      |   |          |
0170  0341             //          :     |  |  |  |  digit count |   |          |
0171  0342             //          :     |  |  |  |  (nb 0 = 16) |   |          |____BASE (usually 2,10 or 16)
0172  0343             //          :     |  |  |  |              |   |
0173  0344             //          :     |  |  |  |              |   |___reserved (not used on Goldelox)
0174  0345             //          :     |  |  |  |              |
0175  0346             //          :     |  |  |  |              |____ string indicatior
0176  0347             //          :     |  |  |  |                      0x80 = [STR]
0177  0348             //          :     |  |  |  |                      0x81 = [CHR]
0178  0349             //          :     |  |  |  |______
0179  0350             //          :     |  |  |           1 = leading zeros included
0180  0351             //          :     |  |  |           0 = leading zeros suppressed
0181  0352             //          :     |  |  |
0182  0353             //          :     |  |  |_______
0183  0354             //          :     |  |           1 = leading zero blanking
0184  0355             //          :     |  |
0185  0356             //          :     |  |_____ sign bit (0 = signed, 1 = unsigned)
0186  0357             //          :     |
0187  0358             //          :     |______ 1 = space before unsigned number
0188  0359   
0189  0360   
0190  0361             func translate("arg1","arg2","arg3","arg4"), 1; // list translator (internal use only)
0191  0362             // Syntax   :  This function is used only by the compiler
0192  0363             // Usage    :   Lookup8 and Lookup16
0193  0364             // Notes    : Reserved for use by compiler only, no use to the programmer
0194  0365   
0195  0366             func putstr("string"), 1;            // print string to current output device
0196  0367             // Syntax   : putstr(pointer);
0197  0368             // Usage    : putstr("HELLO\n");
0198  0369             // Notes    : putstr prints a string to the current output stream, usually the display. The argument can be
0199  0370             //          : a string constant, a pointer to a string, a pointer to an array, or a pointer to a data statement.
0200  0371             //          : The output of putstr can be redirected to the communications port, the media, or memory
0201  0372             //          : using the to(...); function.
0202  0373             //          : A string constant is automatically terminated with a zero.
0203  0374             //          : A string in a data statement is not automatically terminated with a zero.
0204  0375             //          : All variables in 4DGL are 16bit, if an array is used for holding 8 bit characters, each array
0205  0376             //          : element packs 1 or 2 characters.
0206  0377             //          :
0207  0378             //          : Returns the pointer to the item that was printed.
0208  0379   
0209  0380             //==============================================//
0210  0381             // Memory Access Function Prototypes            //
0211  0382             //==============================================//
0212  0383   
0213  0384             func peekB("address"), 1;                       // read a byte from system or user memory
0214  0385             // Syntax   : peekB(address);
0215  0386             // Usage    : myvar := peekB(GFX_XMAX);
0216  0387             // Notes    : This function returns the 8 bit value that is stored at address.
0217  0388             //          : The peekB(..) and pokeB(..) functions are usually only used with internal system byte
0218  0389             //          : registers using the pre-defined constants. If peekB(..) or pokeB(..) are used to access other
0219  0390             //          : locations, the address must be doubled to get the correct pointer address.
0220  0391             //          :
0221  0392             //          : Address: The address of a memory byte. The address is usually a pre-defined system
0222  0393             //          : register address constant, The arguments can be a variable, array element, expression or constant.
0223  0394             //          : Return: The 8 bit value stored at address.
0224  0395   
0225  0396             func peekW("address"), 1;                       // read a word from system or user memory
0226  0397             // Syntax   : peekW(address);
0227  0398             // Usage    : myvar := peekW(SYSTEM_TIMER_LO);
0228  0399             // Notes    : This function returns the 16 bit value that is stored at address.
0229  0400             //          : The address of a memory word. The address is usually a pre-defined system register address constant,
0230  0401             //          : The arguments can be a variable, array element, expression or constant.
0231  0402   
0232  0403             func pokeB("address", "bytevalue"), 0;          // write a byte to system or user memory
0233  0404             // Syntax   : pokeB(address, byte_value);
0234  0405             // Usage    : pokeB(CLIP_TOP, 10);
0235  0406             // Notes    : This function writes a 8 bit value to a location specified by address.
0236  0407             //          : The peekB(..) and pokeB(..) functions are usually only used with internal system byte registers using the
0237  0408             //          : pre-defined constants. If peekB(..) or pokeB(..) are used to access other locations, the address must be
0238  0409             //          : doubled to get the correct pointer address.
0239  0410             //          :
0240  0411             //          : address: Address of a memory byte. It is usually a pre-defined system register address constant
0241  0412             //          : byte_value: The lower 8 bits of byte_value will be stored at address.
0242  0413             //          : Returns TRUE if poke address was a legal address (usually ignored).
0243  0414   
0244  0415             func pokeW("address", "wordvalue"), 0;          // write a word to system or user memory
0245  0416             // Syntax   : pokeW(address, word_value);
0246  0417             // Usage    : pokeW(TIMER2, 5000);
0247  0418             // Notes    : This function writes a 16 bit value to a location specified by address.
0248  0419             //          :
0249  0420             //          : Address: Address of a memory word. The address is usually a pre-defined system register  address constant
0250  0421             //          : word_value: The 16 bit word_value will be stored at address.
0251  0422             //          : The arguments can be a variable, array element, expression or constant.
0252  0423             //          :
0253  0424             //          : Returns TRUE if poke address was a legal address (usually ignored).
0254  0425   
0255  0426             //==============================================//
0256  0427             // bit manipulators                             //
0257  0428             //==============================================//
0258  0429   
0259  0430             func bits_Set("address","mask"), 0;             // set required bit(s) in memory (16bit operation)
0260  0431             // Syntax   : bits_Set(address, mask);
0261  0432             // Usage    : bits_Set(myval, 0xC0);
0262  0433             // Notes    : This function sets the required bits at address by 'ORing' the mask with the value stored at address.
0263  0434             //          : The bits_Set, bits_Clear, bits_Flip and bits_Test functions can only be used for user memory and will
0264  0435             //          : not work with system register variables
0265  0436             //          :
0266  0437             //          : address :     The address of a user memory location.
0267  0438             //          : mask    :    The 16 bit mask containing bits to be set.
0268  0439             //          : The arguments can be a variable, array element, expression or constant.
0269  0440   
0270  0441             func bits_Clear("address","mask"), 0;           // clear required bit(s) in memory (16bit operation)
0271  0442             // Syntax   : bits_Clear(address, mask);
0272  0443             // Usage    : bits_Clear(myval, 0x3C00);
0273  0444             // Notes    : This function clears the required bits at address by 'ANDing' the inverted mask with the value stored at
0274  0445             //          : address.
0275  0446             //          : The bits_Set, bits_Clear, bits_Flip and bits_Test functions can only be used for user memory and will not
0276  0447             //          : work with system register variables.
0277  0448             //          :
0278  0449             //          : address:     The address of a user memory location.
0279  0450             //          : mask   :     The 16 bit mask containing bits to be cleared.
0280  0451             //          : The arguments can be a variable, array element, expression or constant.
0281  0452   
0282  0453             func bits_Flip("address","mask"), 0;            // invert required bit(s) in memory (16bit operation)
0283  0454             // Syntax   : bits_Flip(address, mask);
0284  0455             // Usage    : bits_Flip(myval, 0x8802);
0285  0456             // Notes    : This function flips the required bits at address by 'XORing' the mask with the value stored at address.
0286  0457             //          : The bits_Set, bits_Clear, bits_Flip and bits_Test functions can only be used for user memory and will not
0287  0458             //          : work with system register variables.
0288  0459             //          :
0289  0460             //          : address: The address of a user memory location.
0290  0461             //          : mask   : The 16 bit mask containing bits to be flipped.
0291  0462             //          : The arguments can be a variable, array element, expression or constant.
0292  0463   
0293  0464             func bits_Test("address","mask"), 1;            // test required bit(s) in memory (16bit operation)
0294  0465   
0295  0466             //==============================================//
0296  0467             // Math Functions                               //
0297  0468             //==============================================//
0298  0469   
0299  0470             func ABS("value"), 1;                           // return a positive number
0300  0471             // Syntax   : ABS(value);
0301  0472             // Usage    : var := ABS(arg);
0302  0473             // Notes    : Returns the absolute value of an argument
0303  0474   
0304  0475             func MIN("value1", "value2"), 1;                // return the smaller of 2 numbers
0305  0476             // Syntax   : MIN(value1, value2);
0306  0477             // Usage    : var := MIN(arg1, arg2);
0307  0478             // Notes    : Returns the minimum of 2 arguments
0308  0479   
0309  0480             func MAX("value1", "value2"), 1;                // return the larger of 2 numbers
0310  0481             // Syntax   : MAX(value1, value2);
0311  0482             // Usage    : var := MAX(arg1, arg2);
0312  0483             // Notes    : Returns the maximum of 2 arguments
0313  0484   
0314  0485             func SWAP("*var", "*var"), 0;                   // swap 2 variables, arguments must point to variables
0315  0486             // Syntax   : SWAP(var1, var2);
0316  0487             // Usage    : SWAP(var1, var2);
0317  0488             // Notes    : Swaps the contents of 2 variables or memory locations
0318  0489   
0319  0490             func SIN("angle"), 1;                           // return SIN of angle
0320  0491             // Syntax   : SIN(angle);
0321  0492             // Usage    : var := SIN(arg);
0322  0493             // Notes    : Returns the sine in radians of an argument in degrees
0323  0494             //          : the returned value range is from 127 to -127. The real
0324  0495             //          : cosine values vary from 1.0 to -1.0 so appropriate
0325  0496             //          : scaling must be done in user code.
0326  0497   
0327  0498             func COS("angle"), 1;                           // return COS of angle
0328  0499             // Syntax   : COS(angle);
0329  0500             // Usage    : var := COS(arg);
0330  0501             // Notes    : Returns the cosine in radians of an argument in degrees
0331  0502             //          : the returned value range is from 127 to -127. The real
0332  0503             //          : cosine values vary from 1.0 to -1.0 so appropriate
0333  0504             //          : scaling must be done in user code.
0334  0505   
0335  0506             func RAND(), 1;                                 // return a pseudo random number
0336  0507             // Syntax   : RAND();
0337  0508             // Usage    : var := RAND();
0338  0509             // Notes    : Returns a random number between 0 and 0xFFFF.
0339  0510             //          : The random number generator must first be seeded
0340  0511             //          : by using the SEED(number) function.
0341  0512   
0342  0513             func SEED("number"), 0;                         // re-seed the pseudo random number generator
0343  0514             // Syntax   : SEED(number);
0344  0515             // Usage    : SEED(arg);
0345  0516             // Notes    : Seeds the random number generator.
0346  0517   
0347  0518             func OVF(), 1;                                  // returns upper 16bits of 32bit results
0348  0519             // Syntax   : OVF();
0349  0520             // Usage    : var:= OVF();
0350  0521             // Notes    :
0351  0522   
0352  0523             func SQRT("number"), 1;                         // return square root of a number
0353  0524             // Syntax   : SQRT(number);
0354  0525             // Usage    : var := SQRT(number);
0355  0526             // Notes    :
0356  0527   
0357  0528             //==============================================//
0358  0529             // Text Control Function                        //
0359  0530             //==============================================//
0360  0531   
0361  0532             func txt_MoveCursor("line", "column"), 0;       // move to required text position (font size related)
0362  0533             // Syntax   : txt_SetCursor(line, column);
0363  0534             // Usage    : txt_SetCursor(arg1, arg2);
0364  0535             // Notes    : Moves the text Cursor to a new screen position set by
0365  0536             //          : line,column parameters.
0366  0537   
0367  0538             func txt_Set("mode", "value"), 0;               // various functions, (see constants below)
0368  0539             // Syntax   : txt_Set(mode, value);
0369  0540             // Usage    : txt_Set(arg1, arg2);
0370  0541             // Notes    : Sets various text related parameters used by other functions
0371  0542             //          :
0372  0543             //          : mode = TEXT_COLOUR (mode 0)
0373  0544             //          : txt_Set(TEXT_COLOUR, value);
0374  0545             //          : value = 0 to 0xFFFF, Black to White
0375  0546             //          : Sets the Text colour for the display
0376  0547             //          : Default = GREEN.
0377  0548             //          :
0378  0549             //          : mode = TEXT_HIGHLIGHT (mode 1)
0379  0550             //          : txt_Set(TEXT_HIGHLIGHT, value);
0380  0551             //          : value = 0 to 0xFFFF, Black to White
0381  0552             //          : Sets the Text background colour for the display. Effective
0382  0553             //          : when text mode is Opaque.
0383  0554             //          : Default = BLACK.
0384  0555             //          :
0385  0556             //          : mode = FONT_ID (mode 2)
0386  0557             //          : txt_Set(FONT_ID, value);
0387  0558             //          : value = FONT1, FONT2 or FONT3 for internal fonts
0388  0559             //          : else this value is the name of a font included
0389  0560             //          : in a users program in a data statement.
0390  0561             //          : Default = FONT SIZE 3.
0391  0562             //          :
0392  0563             //          : mode = TEXT_WIDTH  (mode 3)
0393  0564             //          : txt_Set(TEXT_WIDTH, value);
0394  0565             //          : value = 1 to 16
0395  0566             //          : Sets the Text Width multiplier
0396  0567             //          : text will be printed magnified horizontally
0397  0568             //          : by this factor, Default = 1.
0398  0569             //          :
0399  0570             //          : mode = TEXT_HEIGHT  (mode 4)
0400  0571             //          : txt_Set(TEXT_HEIGHT, value);
0401  0572             //          : value = 1 to 16
0402  0573             //          : Sets the Text Height multiplier
0403  0574             //          : text will be printed magnified vertically
0404  0575             //          : by this factor, Default = 1.
0405  0576             //          :
0406  0577             //          : mode = TEXT_XGAP  (mode 5)
0407  0578             //          : txt_Set(TEXT_XGAP, value);
0408  0579             //          : value = 1 to 32
0409  0580             //          : Sets the horizontal gap between characters
0410  0581             //          : The gap is in pixel units, Default = 0
0411  0582             //          :
0412  0583             //          : mode = TEXT_YGAP  (mode 6)
0413  0584             //          : txt_Set(TEXT_YGAP, value);
0414  0585             //          : value = 1 to 32
0415  0586             //          : Sets the vertical gap below characters
0416  0587             //          : The gap is in pixel units, Default = 0
0417  0588             //          :
0418  0589             //          : mode = TEXT_PRINTDELAY  (mode 7) DEPRECATED
0419  0590             //          : txt_Set(TEXT_PRINTDELAY, value);
0420  0591             //          : value = 0 to 255
0421  0592             //          : Sets the delay time (in ms) during character
0422  0593             //          : printing to give a 'teletype' like effect.
0423  0594             //          : Often used to attract attention to a string
0424  0595             //          : being printed which can often be missed if
0425  0596             //          : just suddenly appearing or changing.
0426  0597             //          : Default = 0 ms.
0427  0598             //          :
0428  0599             //          : mode = TEXT_OPACITY (mode 8)
0429  0600             //          : txt_Set(TEXT_OPACITY, value);
0430  0601             //          : value = TRANSPARENT (0) = Text Trasparent
0431  0602             //          : value = OPAQUE (1) = Text Opaque
0432  0603             //          : Sets the Opacity/Transparency of the text
0433  0604             //          : Default = 0 or TRANSPARENT
0434  0605             //          :
0435  0606             //          : mode = TEXT_BOLD (mode 9)
0436  0607             //          : txt_Set(TEXT_BOLD, value);
0437  0608             //          : value = dont care
0438  0609             //          : Sets Bold Text mode for the next string or char
0439  0610             //          : The feature automatically resets after printing
0440  0611             //          : using putstr or print has completed
0441  0612             //          :
0442  0613             //          : mode = TEXT_ITALIC (mode 10)
0443  0614             //          : txt_Set(TEXT_ITALIC, value);
0444  0615             //          : value = dont care
0445  0616             //          : Sets Italic Text mode for the next string or char
0446  0617             //          : The feature automatically resets after printing
0447  0618             //          : using putstr or print has completed
0448  0619   
0449  0620             //          : mode = TEXT_INVERSE (mode 11)
0450  0621             //          : txt_Set(TEXT_INVERSE, value);
0451  0622             //          : value = dont care
0452  0623             //          : Sets Inverse Text mode for the next string or char
0453  0624             //          : The feature automatically resets after printing
0454  0625             //          : using putstr or print has completed
0455  0626             //          :
0456  0627             //          : mode = TEXT_UNDERLINED (mode 12)
0457  0628             //          : txt_Set(TEXT_UNDERLINED, value);
0458  0629             //          : value = dont care
0459  0630             //          : Sets Underlined Text mode for the next string or char
0460  0631             //          : The feature automatically resets after printing
0461  0632             //          : using putstr or print has completed
0462  0633             //          :
0463  0634             //          : mode = TEXT_ATTRIBUTES (mode 13)
0464  0635             //          : txt_Set(TEXT_ATTRIBUTES, value);
0465  0636             //          : value = bits are defined as:
0466  0637             //          :  BOLD        16          // TEXT_ATTRIBUTES bold text (auto reset)
0467  0638             //          :  ITALIC      32          // TEXT_ATTRIBUTES italic text (auto reset)
0468  0639             //          :  INVERSE     64          // TEXT_ATTRIBUTES inverse text (auto reset)
0469  0640             //          :  UNDERLINED  128         // TEXT_ATTRIBUTES underlined text (auto reset)
0470  0641             //          : Allows a combination of text attributes to be defined together
0471  0642             //          : by 'or'ing the bits together.
0472  0643             //          : Example: txt_Set(TEXT_ATTRIBUTES, BOLD | INVERSE); // bold + inverse
0473  0644             //          : The feature automatically resets after printing
0474  0645             //          : using putstr or print has completed.
0475  0646             //          : Bits 0-3 and 8-15 are reserved for future attributes.
0476  0647   
0477  0648             //==============================================//
0478  0649             // Hardware Function Prototypes                 //
0479  0650             //==============================================//
0480  0651             //        OUTPUT      0
0481  0652             //        INPUT       1
0482  0653             //        ANALOGUE_8  2
0483  0654             //        ANALOGUE_10 3
0484  0655             //        ONEWIRE     4
0485  0656             //        SOUND        5
0486  0657   
0487  0658             func pin_Set("mode", "pin"), 0;                 // set pin to required mode
0488  0659             // Syntax   : pin_Set(mode, pin);
0489  0660             // Usage    : pin_Set(arg1, arg2);
0490  0661             // Notes    : Sets the appropriate pins to Inputs or Outputs
0491  0662             //          :
0492  0663   
0493  0664             func pin_HI("pin"), 0;                          // set pin to logic '1'
0494  0665             // Syntax   : pin_HI(pin);
0495  0666             // Usage    : pin_HI(PIN_0);
0496  0667             //          : pin = PIN_1 : set PIN_1 (a.k.a. RUN pin) to output
0497  0668             //          : pin = PIN_2 : set PIN_2 pin to output (not available on GMD1 modules)
0498  0669             // Notes    : Outputs a logic "High" (3.3V) on the appropriate
0499  0670             //          : pin that was previously selected as an Output.
0500  0671   
0501  0672             func pin_LO("pin"), 0;                          // set pin to logic '0'
0502  0673             // Syntax   : pin_LO(pin);
0503  0674             // Usage    : pin_LO(PIN_0);
0504  0675             // Notes    : Outputs a logic "Low" (0V) on the appropriate
0505  0676             //          : pin = PIN_1 : set PIN_1 (a.k.a. RUN pin) to output
0506  0677             //          : pin = PIN_2 : set PIN_2 pin to output (not available on GMD1 modules)
0507  0678             //          : pin that was previously  selected as an Output.
0508  0679   
0509  0680             func pin_Read("pin"), 1;                        // read pin, logic or analogue
0510  0681             // Syntax   : pin_Read(PIN_0);
0511  0682             // Usage    : arg1 := pin_Read(arg2);
0512  0683             // Notes    : Reads the logic state or analogue value of the appropriate
0513  0684             //          : pin that was previously selected as an Input or *Analogue.
0514  0685             //          : pin = 0 : Read the state of the RUN pin
0515  0686             //          : Returns a 0 (logic low) or 1 (logic high) or n Analogue.
0516  0687             //          : *NB: Analogue is only available on PIN_1
0517  0688   
0518  0689             func OW_Reset(), 1;                             // issue 1wire reset command
0519  0690             // Syntax   : OW_Reset();
0520  0691             // Usage    : OW_Reset();
0521  0692             // Notes    : Resets  ONEWIRE device
0522  0693             //          : Returns the status, 0 = ACK.
0523  0694             //          :
0524  0695   
0525  0696             func OW_Read(), 1;                              // read data from 1wire bus
0526  0697             // Syntax   : OW_Read();
0527  0698             // Usage    : arg1 := OW_Read();
0528  0699             // Notes    : Reads value of the ONEWIRE pin
0529  0700             //          : that was previously selected for ONEWIRE comms.
0530  0701             //          :
0531  0702             //          : pin = 0 : the next byte from the ONEWIRE bus
0532  0703   
0533  0704             func OW_Read9(), 1;                             // read data from 1wire bus, 9bit mode
0534  0705             // Syntax   : OW_Read9();
0535  0706             // Usage    : OW_Read9();
0536  0707             // Notes    : Reads 9 bit value of the appropriate ONEWIRE pin
0537  0708             //          : that was previously selected for ONEWIRE comms.
0538  0709             //          :
0539  0710             //          : read the 9 bits from the ONEWIRE bus
0540  0711   
0541  0712             func OW_Write("value"), 0;                      // write value to 1wire device
0542  0713             // Syntax   : OW_Write(arg);
0543  0714             // Usage    : OW_Write(arg);
0544  0715             // Notes    : Sends ONEWIRE data on the appropriate
0545  0716             //          : pin that was previously  selected as ONEWIRE comms.
0546  0717             //          :
0547  0718             //          : write arg to the ONEWIRE bus
0548  0719   
0549  0720             func beep("pitch","duration"), 0;               // generate a note on specified port pin
0550  0721             // Syntax   : beep(note, duration);
0551  0722             // Usage    : Beep(20, 50);
0552  0723             // Notes    : Generates a beep for a certain period of time
0553  0724             //          : note    : A value (usually a constant) specifying the frequency of the note.
0554  0725             //          : duration: specifies the time in milliseconds that the note will be played for.
0555  0726             //          : The arguments can be a variable, array element, expression or constant
0556  0727   
0557  0728             func joystick(), 1;                             // read the joystick value
0558  0729             // Syntax   : Joystick();
0559  0730             // Usage    : var := Joystick();
0560  0731             // Notes    : Returned values are:-
0561  0732             //          :    RELEASED 0
0562  0733             //          :    UP       1
0563  0734             //          :    LEFT     2
0564  0735             //          :    DOWN     3
0565  0736             //          :    RIGHT    4
0566  0737             //          :    FIRE     5
0567  0738   
0568  0739             //==============================================//
0569  0740             // Graphics Mode Function Prototypes            //
0570  0741             //==============================================//
0571  0742   
0572  0743             func gfx_Set("mode", "value"), 0;               // set various graphics functions
0573  0744             // Syntax   : gfx_Set(mode, value);
0574  0745             // Usage    : gfx_Set(arg1, arg2);
0575  0746             // Notes    : Sets various graphics parameters used by other functions
0576  0747             //          :
0577  0748             //          : mode = 0 : PenSize
0578  0749             //          : gfx_Set(PEN_SIZE, value);
0579  0750             //          : value = SOLID   : Object Solid
0580  0751             //          : value = OUTLINE : Object Outline
0581  0752             //          : Sets the size of the Pen used by most graphics objects
0582  0753             //          :
0583  0754             //          : mode = 1 : Background Colour
0584  0755             //          : gfx_Set(1, value);
0585  0756             //          : value = 0 to 0xFFFF, Black to White
0586  0757             //          : Sets the Background colour of the screen for gfx_Cls();
0587  0758             //          :
0588  0759             //          : mode = 2 : Object Colour
0589  0760             //          : gfx_Set(OBJECT_COLOUR, value);
0590  0761             //          : value = 0 to 0xFFFF, Black to White
0591  0762             //          : Sets the Object colour used in various functions
0592  0763             //          : LineTo(,,); LineRel(,,); BoxTo(,,); Dot(); etc.
0593  0764             //          :
0594  0765             //          : mode = 3 : Clipping
0595  0766             //          : gfx_Set(CLIPPING, value);
0596  0767             //          : value = OFF : Clipping disabled
0597  0768             //          : value = ON  : Clipping enabled
0598  0769             //          : Enables/Disables the Clipping feature
0599  0770             //          :
0600  0771             //          : mode = 7 : Set required screen behaviour
0601  0772             //          : gfx_Set(SCREEN_MODE, value);
0602  0773             //          : value = LANDSCAPE         1
0603  0774             //          : value = LANDSCAPE_R     2
0604  0775             //          : value = PORTRAIT         3
0605  0776             //          : value = PORTRAIT_R     4
0606  0777             //          :
0607  0778             //          : mode = 8 : Outline Colour
0608  0779             //          : gfx_Set(OUTLINE_COLOUR, value);
0609  0780             //          : value = 1 to 0xFFFF, OFF to White
0610  0781             //          : Sets the Rectangle or Circle objects outline colour
0611  0782             //          : If outline colour, is 0, OUTLINE_COLOUR feature is disabled
0612  0783             //          : gfx_Set(OUTLINE_COLOUR, OFF); may be used for this
0613  0784             //          :
0614  0785             //          : mode = 9 : Contrast
0615  0786             //          : gfx_Set(CONTRAST, value);
0616  0787             //          : value = 1 to 16, 1=lowest, 16=highest contrast
0617  0788             //          : value = 0 puts display into low power mode.
0618  0789             //          : Sets the contrast
0619  0790             //          : gfx_Set(CONTRAST, OFF); may be used for this
0620  0791   
0621  0792             func gfx_Cls(), 0;                    // clear the screen
0622  0793             // Syntax   : gfx_Cls();
0623  0794             // Usage    : gfx_Cls();
0624  0795             // Notes    : Clears the screen with current background colour
0625  0796   
0626  0797             func gfx_MoveTo("x", "y"), 0;                   // set glb_X1 and glb_Y1 to required co-ordinate
0627  0798             // Syntax   : gfx_MoveTo(x, y);
0628  0799             // Usage    : gfx_MoveTo(arg1, arg2);
0629  0800             // Notes    : Moves the origin to a new x,y position
0630  0801   
0631  0802             func gfx_MoveRel("x", "y"), 0;                  // set glb_X1 and glb_Y1 to new relative offset
0632  0803             // Syntax   : gfx_MoveTo(x, y);
0633  0804             // Usage    : gfx_MoveTo(arg1, arg2);
0634  0805             // Notes    : Moves the origin relative to  x,y and sets a new position
0635  0806   
0636  0807             func gfx_LineTo("x1", "y1"), 0;                 // draw line from current origin to new point
0637  0808             // Syntax   : gfx_LineTo(x1, y1);
0638  0809             // Usage    : gfx_LineTo(arg1, arg2);
0639  0810             // Notes    : Draws a Line from the origin x,y to x1,y1.
0640  0811             //          : The new origin is then set to x1, y1. Line colour needs
0641  0812             //          : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
0642  0813   
0643  0814             func gfx_LineRel("x1", "y1"), 0;                // draw line from current origin to new relative offset
0644  0815             // Syntax   : gfx_LineRel(x1, y1);
0645  0816             // Usage    : gfx_LineRel(arg1, arg2);
0646  0817             // Notes    : Draws a Line from the origin x,y to x1,y1.
0647  0818             //          : Unlike gfx_MoveTo() the origin is not updated with x1, y1. Line colour needs
0648  0819             //          : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
0649  0820   
0650  0821             func gfx_Line("x1", "y1", "x2", "y2", "colr"), 0;  // draw line, can be patterned
0651  0822             // Syntax   : gfx_Line(x1, y1, x2, y2, colr);
0652  0823             // Usage    : gfx_Line(arg1, arg2, arg3, arg4, arg5);
0653  0824             // Notes    : Plots a coloured Line from x1,y1 to x2,y2 on the screen
0654  0825   
0655  0826             func gfx_Hline("y", "x1", "x2", "colr"), 1;     // draw Hline, can be patterned
0656  0827             // Syntax   : gfx_Hline(y, x1, x2, colr);
0657  0828             // Usage    : var := gfx_Hline(arg1, arg2, arg3, arg4);
0658  0829             // Notes    : Plots a coloured Horizontal Line y pixels away from origin
0659  0830             //          : starting from x1 to x2
0660  0831             //          : Returns number of pixels plotted
0661  0832   
0662  0833             func gfx_Vline("x", "y1", "y2", "colr"), 1;    // draw Vline, can be patterned
0663  0834             // Syntax   : gfx_Vline(x, y1, y2, colr);
0664  0835             // Usage    : var := gfx_Vline(arg1, arg2, arg3, arg4);
0665  0836             // Notes    : Plots a coloured Vertical Line x pixels away from origin
0666  0837             //          : starting from y1 to y2
0667  0838             //          : Returns number of pixels plotted
0668  0839   
0669  0840             func gfx_Rectangle("x1" ,"y1", "x2", "y2", "colr"), 0;  // draw open rectangle,line can be patterned
0670  0841             // Syntax   : gfx_Rectangle(x1, y1, x2, y2, colr);
0671  0842             // Usage    : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
0672  0843             // Notes    : Plots a coloured Outline Rectangle from top corner (x1,y1) to
0673  0844             //          : bottom corner (x2,y2) on the screen.
0674  0845   
0675  0846             func gfx_RectangleFilled("x1","y1","x2","y2","colr"), 0;  // draw filled rectangle
0676  0847             // Syntax   : gfx_Rectangle(x1, y1, x2, y2, colr);
0677  0848             // Usage    : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
0678  0849             // Notes    : Plots a coloured Solid Rectangle from top corner (x1,y1) to
0679  0850             //          : bottom corner (x2,y2) on the screen.
0680  0851   
0681  0852             func gfx_Circle("x", "y", "rad", "colr"), 0;  // draw open circle
0682  0853             // Syntax   : gfx_Circle(x, y, rad, colr);
0683  0854             // Usage    : gfx_Circle(arg1, arg2, arg3, arg4);
0684  0855             // Notes    : Plots a coloured outline Circle on the screen at centre x,y with radius = rad
0685  0856   
0686  0857             func gfx_CircleFilled("x", "y", "rad", "colr"), 0;        // draw filled circle
0687  0858             // Syntax   : gfx_CircleFilled(x, y, rad, colr);
0688  0859             // Usage    : gfx_CircleFilled(arg1, arg2, arg3, arg4);
0689  0860             // Notes    : Plots a coloured Solid Circle on the screen at centre x,y with radius = rad
0690  0861   
0691  0862             func gfx_PutPixel("x", "y", "colr"), 0;      // set point at x y
0692  0863             // Syntax   : gfx_PutPixel(x, y, colr);
0693  0864             // Usage    : gfx_PutPixel(arg1, arg2, arg3);
0694  0865             // Notes    : Plots a coloured pixel on the screen at x,y location
0695  0866   
0696  0867             func gfx_GetPixel("x", "y"), 1;             // read colour at point x y
0697  0868             // Syntax   : gfx_GetPixel(x, y);
0698  0869             // Usage    : var := gfx_GetPixel(arg1, arg2);
0699  0870             // Notes    : Reads and returns the colour value of a pixel at location x,y
0700  0871   
0701  0872             func gfx_Triangle("x1","y1","x2","y2","x3","y3","colr"), 0; // draw an open triangle
0702  0873             // Syntax   : gfx_Triangle(x1, y1, x2, y2, x3, y3, colr);
0703  0874             // Usage    : gfx_Triangle(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
0704  0875             // Notes    : Plots a coloured outline Triangle from between 3 vertices: x1,y1 x2,y2 x3,y3
0705  0876             //          : Vertices must be specified in an anti-clockwise fashion
0706  0877   
0707  0878             func gfx_OrbitInit("&x_orb", "&y_orb"), 0;  // set result holders for orbit command
0708  0879             // Syntax   : gfx_OrbitInit(&x_orb, &y_orb);
0709  0880             // Usage    : gfx_OrbitInit(&arg1, &arg2);
0710  0881             // Notes    : Sets up the Orbit function parameters.
0711  0882             //          : &x_orb, &y_orb: calcualted Orbit coordiantes. These are pointers to local
0712  0883             //          : variables that get updated after calling gfx_Orbit(,,) function.
0713  0884             //          : The coordiantaes are calculated relative to the origin
0714  0885             //          : obtained by using the gfx_MoveTo(x, y) function.
0715  0886   
0716  0887             func gfx_Orbit("angle", "distance"), 0;     // calculate point at angle, distance
0717  0888             // Syntax   : gfx_Orbit(angle, distance);
0718  0889             // Usage    : gfx_Orbit(arg1, arg2);
0719  0890             // Notes    : The Orbit function calcualtes the x, y coordinates of a distant point whose
0720  0891             //          : only known parameters are the angle and the distance from the current origin.
0721  0892   
0722  0893             func gfx_Polyline("n", "&vx", "&vy", "colr"), 0;  // draw a polyline from a table of points
0723  0894             // Syntax   : gfx_Polyline(n, &vx, &vy, colr);
0724  0895             // Usage    : gfx_Polyline(arg1, x[array], y[array], arg2);
0725  0896             // Notes    : This function is very similar to the Polygon function
0726  0897             //          : with the exception of the 1st and the last vertices not joined.
0727  0898   
0728  0899             func gfx_Polygon("n", "&vx", "&vy", "colr"), 0;   // draw a polygon from a table of points
0729  0900             // Syntax   : gfx_Polygon(n, &vx, &vy, colr);
0730  0901             // Usage    : gfx_Polygon(arg1, x[array], y[array], arg2);
0731  0902             // Notes    : Plots a coloured Polygon between specified vertices: x1,y1 x2,y2 .. xn,yn
0732  0903             //          : Vertices must be minimum of 3 and can be specified in any fashion
0733  0904   
0734  0905             func gfx_Dot(), 0;                              // set point at glb_X glb_Y, default colour
0735  0906             // Syntax   : gfx_Dot();
0736  0907             // Usage    : gfx_Dot();
0737  0908             // Notes    : Places a coloured dot at the origin
0738  0909   
0739  0910             func gfx_Bullet("r"), 0;                        // draw circle at glb_X glb_Y, default colour
0740  0911             // Syntax   : gfx_Dot(r);
0741  0912             // Usage    : gfx_Dot(radius);
0742  0913             // Notes    : Places a coloured circle at the origin with radius r
0743  0914             //          : colour needs to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
0744  0915             //          : and the PenSize setting determines if circle is solid or outline.
0745  0916   
0746  0917             func gfx_IncX(), 1;                            // increment global origin glb_X, returning new value
0747  0918             // Syntax   : gfx_IncX();
0748  0919             // Usage    : var := gfx_IncX();
0749  0920             // Notes    : Increments the x coordinate of the origin
0750  0921             // Notes    : Returns new value
0751  0922   
0752  0923             func gfx_IncY(), 1;                            // increment global origin glb_Y, returning new value
0753  0924             // Syntax   : gfx_IncY();
0754  0925             // Usage    : var := gfx_IncY();
0755  0926             // Notes    : Increments the y coordinate of the origin
0756  0927             // Notes    : Returns new value
0757  0928   
0758  0929             func gfx_BoxTo("x1", "y1"), 0;                 // draw rectangle from current origin to x1 y1
0759  0930             // Syntax   : gfx_BoxTo(x1, y1);
0760  0931             // Usage    : gfx_BoxTo(arg1, arg2);
0761  0932             // Notes    : Draws a Rectangle from the origin x,y to x1,y1.
0762  0933             //          : The new origin is then set to x1,y1. Rectangle colour needs
0763  0934             //          : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
0764  0935             //          : and the PenSize setting determines if Box is solid or outline.
0765  0936   
0766  0937             func gfx_ClipWindow("x1" ,"y1", "x2", "y2"), 0;  // set the cipping area
0767  0938             // Syntax   : gfx_ClipWindow(x1, y1, x2, y2);
0768  0939             // Usage    : gfx_ClipWindow(arg1, arg2, arg3, arg4);
0769  0940             // Notes    : Specifies a clipping window region on the screen such that any objects
0770  0941             //          : and text placed onto the screen will be clipped and displayed only
0771  0942             //          : within that region. For the clipping window to take effect, "Clipping"
0772  0943             //          : must be enabled seperately using the gfx_Set(CLIPPING, ON) function.
0773  0944   
0774  0945             func gfx_ChangeColour("oldcolr", "newcolr"), 0;  // change pixel colour in clipping area
0775  0946             // Syntax   : gfx_ChangeColour(oldcolr, newcolr);
0776  0947             // Usage    : gfx_ChangeColour(0xFF00, 0xFFFF);
0777  0948             // Notes    : Changes the pixel colour in the currently focussed clipping region
0778  0949   
0779  0950             func gfx_FocusWindow(), 1;                      // focus on the clipping area, returning the pixel count
0780  0951             // Syntax   : gfx_FocusWindow();
0781  0952             // Usage    : var := gfx_FocusWindow();
0782  0953             // Notes    : sets the focus on the clipping region and returns number of pixels in the region.
0783  0954   
0784  0955             func gfx_SetClipRegion(), 1;                    // set clipping area to the most recent extents
0785  0956             // Syntax   : gfx_SetClipRegion();
0786  0957             // Usage    : VAR := gfx_SetClipRegion();
0787  0958             // Notes    :
0788  0959   
0789  0960             //==============================================//
0790  0961             // uSD/FLASH Function Prototypes                //
0791  0962             //==============================================//
0792  0963   
0793  0964             func media_Video("x", "y"), 0;                  // display movie at position x y
0794  0965             // Syntax   : media_Video(x, y);
0795  0966             // Usage    : media_Video(arg1, arg2);
0796  0967             // Notes    : Play a Video/Animation clip from the uSD card at screen location
0797  0968             //          : specified by x,y (top left corner). The location of the clip in the
0798  0969             //          : uSD card must be specified by media_setSector(Video_Sector_Add) function.
0799  0970   
0800  0971             func media_VideoFrame("x", "y","framenumber"), 0;// display required frame from a movie at x y
0801  0972             // Syntax   : media_VideoFrame(Frame_number);
0802  0973             // Usage    : arg1 := media_VideoFrame();
0803  0974             // Notes    : After a pointer to a valid video has been set with media_SetSector,
0804  0975             //          : calling this function shows each fram sequentially, returning
0805  0976             //          : the number of frames remaining. The position of the image is
0806  0977             //          : at the current origin as set with gfx_MoveTo(...);
0807  0978   
0808  0979             func media_SetAdd("HiWord", "LoWord"), 0;       // set stream byte address
0809  0980             // Syntax   : media_SetAdd(AddHiWord, AddLoWord);
0810  0981             // Usage    : media_SetAdd(arg1, arg2);
0811  0982             // Notes    : Set uSD internal Address pointer for bytewise access
0812  0983   
0813  0984             func media_SetSector("HiWord", "LoWord"), 0;    // set stream sector address
0814  0985             // Syntax   : media_SetSector(SectHiWord, SectLoWord);
0815  0986             // Usage    : media_SetSector(arg1, arg2);
0816  0987             // Notes    : Set uSD internal Sector pointer for sector block access
0817  0988   
0818  0989             func media_ReadByte(), 1;                       // read a byte at the current stream position
0819  0990             // Syntax   : media_RdByte();
0820  0991             // Usage    : var := media_RdByte();
0821  0992             // Notes    : Reads and Returns a single byte of data from the
0822  0993             //          : uSD card pointed to by the internal Address pointer.
0823  0994             //          : After the read the Address pointer is automatically
0824  0995             //          : incremented by 1.
0825  0996   
0826  0997             func media_ReadWord(), 1;                       // read a word at the current stream position
0827  0998             // Syntax   : media_ReadWord();
0828  0999             // Usage    : var := media_ReadWord();
0829  1000             // Notes    : Reads and Returns a single word of data from the
0830  1001             //          : uSD card pointed to by the internal Address pointer.
0831  1002             //          : After the read the Address pointer is automatically
0832  1003             //          : incremented by 1.
0833  1004   
0834  1005             func media_WriteByte("byte"), 1;                // write a byte to the current stream position
0835  1006             // Syntax   : media_WriteByte(arg1);
0836  1007             // Usage    : var := media_WriteByte(arg1);
0837  1008             // Notes    : Writes and Returns xxxxx
0838  1009             //          : After the write the Address pointer is automatically
0839  1010             //          : incremented by 1.
0840  1011   
0841  1012             func media_WriteWord("word"), 1;                // write a word to the current stream position
0842  1013             // Syntax   : media_WriteWord(arg1);
0843  1014             // Usage    : var := media_WriteWord(arg1);
0844  1015             // Notes    : Writes and Returns xxxxx
0845  1016             //          : After the write the Address pointer is automatically
0846  1017             //          : incremented by 1.
0847  1018   
0848  1019             func media_Image("x", "y"), 0;                  // display image at position x y
0849  1020             // Syntax   : media_Image(x, y);
0850  1021             // Usage    : media_Image(arg1, arg2);
0851  1022             // Notes    : Display an image from the uSD card at screen location
0852  1023             //          : specified by x,y (top left corner). The location of the
0853  1024             //          : Image in the uSD card must be specified by
0854  1025             //          : media_setSector(Image_Sector_Add) function.
0855  1026   
0856  1027             func media_Flush(), 1;                          // after writing to media, flush the sector and write
0857  1028             // Syntax   : media_Flush();
0858  1029             // Usage    : var := media_Flush();
0859  1030             // Notes    : After writing any data to a sector, media_Flush() should be called to ensure that the current sector that
0860  1031             //          : is being written is correctly stored back to the media else write operations may be unpredictable.
0861  1032   
0862  1033             func media_Init(), 1;                           // initialize uSD card
0863  1034             // Usage    : media_Init();
0864  1035             // Notes    : Initialise uSD CARD
0865  1036             //          : Response: 0 = No Card
0866  1037             //          :           1 = Card Initialised
0867  1038   
0868  1039   
0869  1040             //==============================================//
0870  1041             // RTTTL Specific Function Prototypes           //
0871  1042             //==============================================//
0872  1043   
0873  1044             func tune_Play("TunePtr"), 0;                   // play a RTTTL tune string
0874  1045             // Syntax   : tune_Play(TunePtr);
0875  1046             // Usage    : tune_Play("...notes...");
0876  1047             // Notes    : Play a tune string from a data statement or a direct string
0877  1048   
0878  1049             func tune_Pause(), 0;                           // pause RTTTL (sound continues at current note)
0879  1050             // Syntax   : tune_Pause();
0880  1051             // Usage    : tune_Pause();
0881  1052             // Notes    : Suspends any current tune from playing until a tune_Continue(),
0882  1053             //          : tune_Stop(); or a new tune_Play("...") function. The oscillator
0883  1054             //          : is not stopped
0884  1055   
0885  1056             func tune_Continue(), 0;                        // continue RTTTL
0886  1057             // Syntax   : tune_Continue();
0887  1058             // Usage    : tune_Continue();
0888  1059             // Notes    : Continues playing any previously stopped or paused tune
0889  1060   
0890  1061             func tune_Stop(), 0;                            // stop playing RTTTL tune, sound muted
0891  1062             // Syntax   : tune_Stop();
0892  1063             // Usage    : tune_Stop();
0893  1064             // Notes    : Pauses a tune and silences the oscillator until a tune_Continue(),
0894  1065             //          : tune_Stop(), tune_End or a new tune_Play("..."); function
0895  1066   
0896  1067             func tune_End(), 0;                             // cancel a RTTTL tune
0897  1068             // Syntax   : tune_End();
0898  1069             // Usage    : tune_End();
0899  1070             // Notes    : Ends any current tune and resets the tune interpreter
0900  1071   
0901  1072             func tune_Playing(), 1;                         // pol RTTTL player to see if a tune is playing
0902  1073             // Syntax   : tune_Playing();
0903  1074             // Usage    : var := tune_Playing();
0904  1075             // Notes    : returns 1 if tune is playing, 0 if no tune is playing.
0905  1076   
0906  1077             //==============================================//
0907  1078             // Communications Function Prototypes           //
0908  1079             //==============================================//
0909  1080             func com_AutoBaud("timeout"), 1;                // wait for timeout millisconds, retur baud rate if "U" received
0910  1081             // Syntax   : com_AutoBaud(timeout);
0911  1082             // Usage    : arg := com_AutoBaud(500);
0912  1083             //          : enter auto baud mode for "time" milliseconds, wait for "U"
0913  1084             //          : If timeout occurs, a 0 is returned, else the baud rate
0914  1085             //          : divisor calculated is returned for verification if required.
0915  1086   
0916  1087             func com_Init("buf","bufsize","qualifier"), 0;  // set up a interrupt driven ring buffer for comms
0917  1088             // Syntax   : com_Init(buffer, bufsize, qualifier);
0918  1089             // Usage1   : com_Init(mybuf, 20, 0);
0919  1090             // Usage2   : com_Init(mybuf, 20, ':');
0920  1091             // Notes    : initialize a serial capture buffer for the comms input
0921  1092             //          : The program must declare a var array as a circular buffer.
0922  1093             //          : Usage1 declares a circular buffer which will continually
0923  1094             //          : buffer characters.
0924  1095             //          : Usage2 must receive ':' before any characters will
0925  1096             //          : accumulate in the buffer.
0926  1097   
0927  1098             func com_Reset(), 0;                            // reset the ring buffer
0928  1099             // Syntax   : com_Reset();
0929  1100             // Usage    : com_Reset();
0930  1101             // Notes    : reset comms to default polled mode
0931  1102   
0932  1103             func com_Count(), 1;                            // return count of characters in ring buffer
0933  1104             // Syntax   : com_Count();
0934  1105             // Usage    : arg := com_Count();
0935  1106             // Notes    : return count of buffered characters in buffer attachment
0936  1107   
0937  1108             func com_Full(), 1;                             // return TRUE if com buffer filled to capcity
0938  1109             // Syntax   : com_Full();
0939  1110             // Usage    : if (com_Full() ,,,, go read buffer;
0940  1111             // Notes    : return true if buffer full (not necessarily an error if buffer is sized to a packet size)
0941  1112   
0942  1113             func com_Error(), 1;                            // return TRUE if a comms error occurred
0943  1114             // Usage    : if (com_Error() ) ...... take recovery action;
0944  1115             // Notes    : Returns 1 if any low level communications error occurred, else returns 0.
0945  1116   
0946  1117             func com_Sync(), 1;                             // returns TRUE if qualifier has been received
0947  1118             // Syntax   : com_Sync();
0948  1119             // Usage    : var := com_Sync();
0949  1120             // Notes    : return true if sync character has been received in com_Init("...") mode
0950  1121   
0951  1122             func com_Checksum(), 1;                         // returns checksum if employed. 0 = OK
0952  1123             // Syntax   : com_Checksum();
0953  1124             // Usage    : if(!com_Checksum()); processMyPacket();
0954  1125             // Notes    : Transparent to normal operation, a check summing system is operating. If the host sends one extra
0955  1126             //          : character as part of the packet (usually added at the end of the packet) which is the negated value of the
0956  1127             //          : addition of all the previous characters in the packet. Once the com_Full() function reports a buffer full
0957  1128             //          : situation (ie the packet is fully received) , the checksum can be read, and should read zero if the packet
0958  1129             //          : is not corrupted.
0959  1130             //          :
0960  1131             //          : Returns 0 if checksum has been computed correctly.
0961  1132   
0962  1133             func com_PacketSize(), 1;                       // returns size of the comms buffer for packet mode
0963  1134             // Syntax   : com_PacketSize();
0964  1135             // Usage    : If (!com_Count()); print("Waiting....");
0965  1136             // Notes    : com_PacketSize() will indicate how large the packet is ONLY after the packet reception has started.
0966  1137             //          : Although it is usually not required to know the packet size until the packet has actually been read, if it
0967  1138             //          : is a requirement, the count is available as soon as com_Count() becomes non zero. If not in variable
0968  1139             //          : packet length mode, com_PacketSize() just returns the size of the specified buffer.
0969  1140             //          :
0970  1141             //          : Returns the size of a packet if in variable packet length mode, or just the size of the serial buffer if
0971  1142             //          : not variable packet length mode.
0972  1143   
0973  1144             //==============================================//
0974  1145             // Display Initialization                       //
0975  1146             // (for GOLDELOX-GFX2 with external display)    //
0976  1147             //==============================================//
0977  1148   
0978  1149             func disp_Init("INIT_table", "GRAM_code"), 0;   // initialize display with required tables
0979  1150             // Syntax   : disp_Init(initTable, stateMachine);
0980  1151             // Usage    : disp_Init(INIT_tbl, GRAM_sm);
0981  1152             // Notes    : The GOLDELOX-GFX2 needs to be aware of all the display registers and how to access them.
0982  1153             //          : The initialisation and the state machine tables are necessary to achieve this. Refer to the individual
0983  1154             //          : display data sheet available from the display manufacturer.
0984  1155             //          : For hardware platform modules such as uOLED-96-G1(GFX), uOLED-128-G1(GFX), etc the disp_Init(,,) is not
0985  1156             //          : needed. The modules are factory set-up with their display specific configurations.
0986  1157             //          :
0987  1158             //          : initTable   : A reference to the device initialisation table which is stored as a data statement.
0988  1159             //          : stateMachine: A reference to the device state machine table which is stored as a data statement.
0989  1160             //          :
0990  1161   
0991  1162             //==============================================//
0992  1163             // Display Access                               //
0993  1164             //==============================================//
0994  1165   
0995  1166             func disp_WriteByte("value"), 0;                // write a data byte to the display
0996  1167             // Syntax: disp_WriteByte(value);
0997  1168             // Usage    : on a SD1339 display driver IC
0998  1169             //          : #constant DRAW_CIRCLE 0x86
0999  1170             //          : func myCircle(var x, var y, var r, var fillcolour, var linecolour)
1000  1171             //          :     disp_WriteControl(DRAW_CIRCLE);   // Draw Circle command
1001  1172             //          :     disp_WriteByte(x);                // set x1
1002  1173             //          :     disp_WriteByte(y);                // set y1
1003  1174             //          :     disp_WriteByte(r);                // set x2
1004  1175             //          :     disp_WriteByte(linecolour>>8);    // set outline colour Hi byte
1005  1176             //          :     disp_WriteByte(linecolour);       // set outline colour Lo byte
1006  1177             //          :     disp_WriteByte(fillcolour>>8);    // set fill colour Hi byte
1007  1178             //          :     disp_WriteByte(fillcolour);       // set fill colour Lo byte
1008  1179             //          : endfunc
1009  1180             // Notes    : Sends a single byte (which is the lower 8 bits of value) to the display bus. Refer to individual data
1010  1181             //          : sheets for the display for more information. This function is used to extend the capabilities of the user
1011  1182             //          : code to gain access to the the display hardware.
1012  1183             //          :
1013  1184             //          : value Specifies the value to be written to the display data register. Only the lower 8 bits are sent to
1014  1185             //          : the display.
1015  1186   
1016  1187             func disp_WriteControl("value"), 0;             // write a control byte to the display
1017  1188             // Syntax: disp_WriteControl("value");
1018  1189             // Usage    : on a SD1339 display driver IC
1019  1190             //          : #constant DRAW_CIRCLE 0x86
1020  1191             //          : func myCircle(var x, var y, var r, var fillcolour, var linecolour)
1021  1192             //          :     disp_WriteControl(DRAW_CIRCLE);   // Draw Circle command
1022  1193             //          :     disp_WriteByte(x);                // set x1
1023  1194             //          :     disp_WriteByte(y);                // set y1
1024  1195             //          :     disp_WriteByte(r);                // set x2
1025  1196             //          :     disp_WriteByte(linecolour>>8);    // set outline colour Hi byte
1026  1197             //          :     disp_WriteByte(linecolour);       // set outline colour Lo byte
1027  1198             //          :     disp_WriteByte(fillcolour>>8);    // set fill colour Hi byte
1028  1199             //          :     disp_WriteByte(fillcolour);       // set fill colour Lo byte
1029  1200             //          : endfunc
1030  1201             // Notes    : Sends a single byte (which is the lower 8 bits of value) to the display bus. Refer to individual data
1031  1202             //          : sheets for the display for more information. This function is used to extend the capabilities of the user
1032  1203             //          : code to gain access to the the display hardware.
1033  1204             //          : value Specifies the value to be written to the display control register. Only the lower 8 bits are sent to
1034  1205             //          : the display.
1035  1206   
1036  1207             func disp_WriteWord("value"), 0;                // write a word (HI:LO format) to the display
1037  1208             // Syntax   : disp_WriteWord(value);
1038  1209             // Usage    : on a SD1339 display driver IC
1039  1210             //          : #constant DRAW_CIRCLE 0x86
1040  1211             //          : func myCircle(var x, var y, var r, var fillcolour, var linecolour)
1041  1212             //          :     disp_WriteControl(DRAW_CIRCLE);   // Draw Circle command
1042  1213             //          :     disp_WriteByte(x);                // set x1
1043  1214             //          :     disp_WriteByte(y);                // set y1
1044  1215             //          :     disp_WriteByte(r);                // set x2
1045  1216             //          :     disp_WriteWord(linecolour);       // set outline colour
1046  1217             //          :     disp_WriteWord(fillcolour);       // set fill colour
1047  1218             //          : endfunc
1048  1219             // Notes    : Sends a 16 bit value to the display bus. Since the GOLDELOX-GFX2 display data bus is 8bits wide, the HIGH
1049  1220             //          : byte is sent first followed by the LOW byte. Refer to individual data sheets for the display for more
1050  1221             //          : information. This function is used to extend the capabilities of the user code to gain access to the the
1051  1222             //          : display hardware.
1052  1223             //          :
1053  1224             //          : value Specifies the value to be written to the display data register. Only the lower 8 bits are sent to
1054  1225             //          : the display.
1055  1226   
1056  1227             func disp_ReadByte(), 1;                        // read a byte from the display
1057  1228             // Syntax   : disp_ReadByte();
1058  1229             // Usage    : gfx_ClipWindow(40,40,44,44); // within a small block on the display
1059  1230             //          : gfx_FocusWindow(); // focus GRAM
1060  1231             //          : pixel_Hi:= dispReadByte(); // read hi byte of first pixel
1061  1232             //          : pixel_Lo:= dispReadByte(); // read lo byte of first pixel
1062  1233             // Notes    : Reads a byte from the display after an internal register or GRAM access has been set.
1063  1234             //          : value Returns the 8bit data that was read from the display. Only the lower 8bits are valid.
1064  1235   
1065  1236             func disp_ReadWord(), 1;                        // read a word from the display (HI:LO format)
1066  1237             // Syntax   : disp_ReadWord();
1067  1238             // Usage    : gfx_ClipWindow(40,40,44,44); // within a small block on the display
1068  1239             //          : gfx_FocusWindow(); // focus GRAM
1069  1240             //          : pixel := dispReadWord(); // read 1st pixel, HI:LO order
1070  1241             // Notes    : Reads a 16bit word from the display after an internal register or GRAM access has been set.
1071  1242             //          : Returns the 16bit data that was read from the display.
1072  1243   
1073  1244             func disp_BlitPixelFill("colr","count"), 0;      // write "count" pixels to the display (8 or 16 bit)
1074  1245             // Syntax   : disp_BlitPixelFill(colour, count);
1075  1246             // Usage    : gfx_ClipWindow(40,40,79,79); // select a block on the display
1076  1247             //          : count := gfx_FocusWindow(); // focus GRAM
1077  1248             //          : myvar:=dispBlitPixelFill(RED,count); // paint the area red
1078  1249             // Notes    : Fills a preselected GRAM screen area with the specified colour. colour Specifies the colour for the
1079  1250             //          : fill. count Specifies the number of pixels to fill.
1080  1251             //          : The arguments can be a variable, array element, expression or constant
1081  1252   
1082  1253             func disp_BlitPixelsToMedia(), 1;               // write current clip window to the media (8 or 16 bit), return pixel count
1083  1254             // Syntax   : disp_BlitPixelsToMedia();
1084  1255             // Usage    : media_SetSector(0x0020,0x0000); // we're going to write here
1085  1256             //          : n:=disp_BlitPixelsToMedia (); // save it to sector
1086  1257             // Notes    : Write the selected GRAM area to the media at the current media address. Needs a uSD card.
1087  1258             //          : Returns the number of pixels that were written to the media.
1088  1259   
1089  1260             func disp_BlitPixelsFromCOM("mode"), 0;         // write pixels from the serial port to the currnetly focused GRAM area (8 or 16 bit)
1090  1261             // Syntax   : disp_BlitPixelFromCOM(mode);
1091  1262             // Usage    : gfx_ClipWindow(40,40,59,59); // writing to a 40x40 block on the display.
1092  1263             //          : gfx_FocusWindow(); // NB first focus is just so we can get pixel count of area.
1093  1264             //          : print("Filling ",*IMG_PIXEL_COUNT," pixels");
1094  1265             //          : gfx_FocusWindow();
1095  1266             //          : disp_BlitPixelsFromCOM(0); // get pixels from serial port,
1096  1267             //          : while(*IMG_PIXEL_COUNT); // wait till all the pixels come in
1097  1268             // Notes    : Fills a preselected GRAM screen area with the specified colour.
1098  1269             //          : mode = 0 : specifies 16 bit pixels
1099  1270             //          : mode = pointer : specifies pointer to 16 element colour lookup table for each 4bit pixel value
1100  1271             //          : The arguments can be a variable, array element, expression or constant
1101  1272   
1102  1273             func disp_BlitPixelsToCOM(), 1;                 // write current clip window to the com port (8 or 16 bit), return pixel count
1103  1274             // Syntax   : disp_BlitPixelsToCOM();
1104  1275             // Usage    : gfx_ClipWindow(40,40,44,44);  // within a small block on the display
1105  1276             //          : pixels:=gfx_FocusWindow(); // focus GRAM and get pixel count of area
1106  1277             //          : disp_BlitPixelFill(0x4142, pixels);// fill the area using ASCII values so we can read easily
1107  1278             //          : disp_BlitPixelsToCOM(); // write the pixels to the COM port
1108  1279             // Notes    : Write the selected GRAM area to the serial (COM) port..
1109  1280             //          : Returns the number of pixels that were written to the serial port.
1110  1281   
1111  1282             func disp_BlitPixelsFromMedia("count"), 0;      // write "count" pixels from the current media (default uSD) to the display (8 or 16 bit)
1112  1283             // Syntax   : disp_BlitPixelsFromMedia(pixelcount);
1113  1284             // Usage    : media_SetAdd(0x0002, 0x3C00); // point to required area of an image
1114  1285             //          : disp_BlitPixelsFromMedia(20); // write the next 20 pixels from media to the current GRAM pointer.
1115  1286             // Notes    : Read the required number of pixels consecutively from the current media stream and write
1116  1287             //          : them to the current display GRAM address. For 8bit colour mode, each pixel comprises a single 8bit value.
1117  1288             //          : For 16bit colour, each pixel is composed of 2 bytes, the high order byte is read first, the low order bye
1118  1289             //          : is read next.
1119  1290             //          : pixelcount Specifying the number of pixels to be consecutively read from the media stream.
1120  1291             //          : The arguments can be a variable, array element, expression or constant
1121  1292   
1122  1293             func disp_SkipPixelsFromMedia("count"), 0;      // skip "count" pixels from the current media (default uSD) to the display (8 or 16 bit)
1123  1294             // Syntax   : disp_SkipPixelsFromMedia("count");
1124  1295             // Usage    : disp_SkipPixelsFromMedia(20); // skip the next 20 pixels from media
1125  1296             //          : disp_BlitPixelsFromMedia(20); // write the next 20 pixels from media to the current GRAM pointer.
1126  1297             // Notes    : Skip the required number of pixels consecutively from the current media stream, discarding them. For 8bit
1127  1298             //          : colour mode, each pixel comprises a single 8bit value. For 16bit colour, each pixel is composed of 2
1128  1299             //          : bytes, the high order byte is read first, the low order bye is read next.
1129  1300             //          :
1130  1301             //          : pixelcount Specifying the number of pixels to be consecutively skipped from the media stream.
1131  1302             //          : The arguments can be a variable, array element, expression or constant
1132  1303   
1133  1304             //==============================================//
1134  1305             // unadorned SPI functions                      //
1135  1306             //==============================================//
1136  1307   
1137  1308             func spi_Init("speed","ip_mode","op_mode"), 0;  // set the SPI port, not used if uSD active
1138  1309             // Syntax   : spi_Init(speed, input_mode, output_mode);
1139  1310             // Usage    : spi_Init(speed,ip_mode,op_mode);
1140  1311             // Notes    : Sets up the GOLDELOX-GFX2 SPI port to communicate with SPI devices.
1141  1312             //          : Note: The SPI functions in this section are not necessary when using the memory card or serial flash chips
1142  1313             //          : interfaced to the SPI port. The SPI functions in this section are relevant to those devices other than the
1143  1314             //          : memory card and the serial flash chip used for media access.
1144  1315             //          : speed         : Sets the speed of the SPI port.
1145  1316             //          : input_mode    : Sets the input mode of the SPI port.
1146  1317             //          : output_mode   : Sets the output mode of the SPI port. See diagram below.
1147  1318             //          : The arguments can be a variable, array element, expression or constant
1148  1319   
1149  1320             func spi_Read(), 1;                             // read a raw byte from SPI (lowers CS)
1150  1321             // Syntax   : spi_Read();
1151  1322             // Usage    : var := spi_Read();
1152  1323             // Notes    : This function allows a raw unadorned byte read from the SPI device.
1153  1324             //          : Note: The Chip Select line (SDCS) is lowered automatically.
1154  1325             //          : Returns a single data byte from the SPI device.
1155  1326   
1156  1327             func spi_Write("byte"), 0;                      // write a raw byte to SPI (lowers CS)
1157  1328             // Syntax   : spi_Write("byte");
1158  1329             // Usage    : spi_Write(byte);
1159  1330             // Notes    : This function allows a raw unadorned byte write to the SPI device.
1160  1331             //          : Note: The Chip Select line (SDCS) is lowered automatically.
1161  1332             //          : byte specifies the data byte to be sent to the SPI device.
1162  1333   
1163  1334             func spi_Disable(), 0;                          // disable SPI reading or writing (raise CS)
1164  1335             // Syntax   : spi_Disable();
1165  1336             // Usage    : spi_Disable();
1166  1337             // Notes    : This function raises the Chip Select (SDCS) line of the SPI device, disabling it from further activity.
1167  1338             //          : The CS line will be automatically lowered next time the SPI functions spi_Read() or spi_Write(...) are
1168  1339             //          : used, and also by action of any of the media_ functions.
1169  1340   
1170  1341   
1171  1342             //==============================================//
1172  1343             // flash device specific functions              //
1173  1344             //==============================================//
1174  1345   
1175  1346             func flash_SIG(), 1;                            // read Jedecsignature from SPI Flash device
1176  1347             // Syntax   : flash_SIG();
1177  1348             // Usage    : var := flash_SIG();
1178  1349             // Notes    : If a FLASH storage device is connected to the SPI port, and has been correctly initialised with the
1179  1350             //          : spi_Init(...) function, the Electronic Signature of the device can be read using this function. The only
1180  1351             //          : devices supported so far on the GOLDELOX-GFX2 are the M25Pxx range of devices which are 512Kbit to 32Mbit
1181  1352             //          : (2M x 8) Serial Flash Memory.
1182  1353             //          : Release from Deep Power-down, and Read Electronic Signature. Only the low order byte is valid, the upper
1183  1354             //          : byte is ignored.
1184  1355   
1185  1356             func flash_ID(), 1;                             // read ID code from FLASH device
1186  1357             // Syntax   : flash_ID();
1187  1358             // Usage    : var := flash_ID();
1188  1359             // Notes    : If a FLASH storage device is connected to the SPI port, and has been correctly initialised with the
1189  1360             //          : spi_Init(...) function, the memory type and capacity from the flash device can be read using this function
1190  1361             //          : The only devices supported so far on the GOLDELOX-GFX2 are the M25Pxx range of devices which are 512Kbit to
1191  1362             //          : 32Mbit (2M x 8) Serial Flash Memory.
1192  1363             //          : Reads the memory type and capacity from the serial FLASH device. Hi byte contains type, and low byte
1193  1364             //          : contains capacity. Refer to the device data sheet for further information.
1194  1365   
1195  1366             func flash_BulkErase(), 0;                      // erase the entire FLASH device
1196  1367             // Syntax   : flash_BulkErase();
1197  1368             // Usage    : flash_BulkErase();
1198  1369             // Notes    : If a FLASH storage device is connected to the SPI port, and has been correctly initialised with the
1199  1370             //          : spi_Init(...) function, the FLASH device can be completely erased using this function. The only devices
1200  1371             //          : supported so far on the GOLDELOX-GFX2 are the M25Pxx range of devices which are 512Kbit to 32Mbit (2M x 8)
1201  1372             //          : Serial Flash Memory.
1202  1373             //          : Erases the entire flash media device. The function returns no value, and the operation can take up to 80
1203  1374             //          : seconds depending on the size of the flash device.
1204  1375   
1205  1376             func flash_BlockErase("block"), 1;              // erase the required 64k flash block
1206  1377             // Syntax   : flash_BlockErase("block")
1207  1378             // Usage    : var := flash_BlockErase(block_num)
1208  1379             // Notes    : If a FLASH storage device is connected to the SPI port, and has been correctly initialised with the
1209  1380             //          : spi_Init(...) function, the FLASH block can be erased using this function. The only devices supported so
1210  1381             //          : far on the GOLDELOX-GFX2 are the M25Pxx range of devices which are 512Kbit to 32Mbit (2M x 8) Serial Flash
1211  1382             //          : Memory.
1212  1383             //          : E.g. there are 32 x 64K blocks on a 2Mb flash device.
1213  1384             //          : blockAddress The address of the 64k FLASH block to be erased.
1214  1385             //          : Erases the required block in a FLASH media device. The function returns no value, and the operation
1215  1386             //          : can take up to 3 milliseconds.
1216  1387   
1217  1388             //==============================================//
1218  1389             // user stack operations                        //
1219  1390             //==============================================//
1220  1391   
1221  1392             func setsp("offset"), 0;                        // set the user stack pointer (same as pokeW(USR_SP, n); )
1222  1393             // Syntax   : setsp(index);
1223  1394             // Usage    : setsp(0); // reset the stack pointer
1224  1395             // Notes    : The users stack pointer is zeroed at power up, but it is sometimes necessary to alter the stack pointer
1225  1396             //          : for various reasons, such as running multiple concurrent stacks, or resetting to a known position as part
1226  1397             //          : of an error recovery process.
1227  1398             //          : index: This argument is used to set the users SP to the required position. The stack pointer is set to
1228  1399             //          : zero during power-up initialisation.
1229  1400   
1230  1401             func getsp(), 1;                                // return the current stack pointer (same as peekW(USR_SP); )
1231  1402             // Usage    : push(1234);
1232  1403             //          : print(getsp()); // print the stack index
1233  1404             // Notes    : This function returns the current stack index into the stack array. If the index is zero, there are no
1234  1405             //          : items on the stack.
1235  1406             //          : index: The current stack index.
1236  1407   
1237  1408             func pop(), 1;                                  // pop var off stack
1238  1409             // Syntax   : pop();
1239  1410             // Usage    : push(100);
1240  1411             //          : push(200);
1241  1412             //          : print(pop()+ pop());
1242  1413             // Notes    : This function returns the value at the current stack pointer index. The stack pointer is then
1243  1414             //          : decremented, so it now points to the item below. If the stack pointer is zero, (ie a pop was performed on
1244  1415             //          : an empty stack) the function returns 0 and the stack pointer is not altered (ie it remains at 0).
1245  1416             //          : Returns the value at current stack pointer index.
1246  1417   
1247  1418             func drop("count"), 0;                          // drop n vars off stack
1248  1419             // Syntax   : drop(count);
1249  1420             // Usage    : myvar := 10;
1250  1421             //          : push(1234);
1251  1422             //          : push(5678);
1252  1423             //          : push(myvar);
1253  1424             //          : drop(2);
1254  1425             // Notes    : Decrements the user stack pointer determined by the value n. If n exceeds the stack index, the stack
1255  1426             //          : pointer is zeroed.
1256  1427             //          : count Specifies the number of items to be dropped from the stack.
1257  1428   
1258  1429             func push("item"), 1;                           // push value to stack
1259  1430             // Syntax   : push(val);
1260  1431             // Usage    : Myvar := 10;
1261  1432             //          : push(1234);
1262  1433             //          : push(5678);
1263  1434             //          : push(myvar);
1264  1435             // Notes    : Increment the user stack pointer first and then places the item into the user stack array at the current
1265  1436             //          : position. The stack pointer is now pointing to this new item.
1266  1437             //          : val: Argument to be pushed to the user stack.
1267  1438   
1268  1439             func call(), 1;                                 // exec a function using stacked frame (frame is dropped)
1269  1440             // Syntax   : call()
1270  1441             // Usage    : push(10);
1271  1442             //          : push(10);
1272  1443             //          : push(50);
1273  1444             //          : push(50);
1274  1445             //          : push(0xFFFF);
1275  1446             //          : push(gfx_RectangleFilled); // push the function call address
1276  1447             //          : push(5); // push the argument count
1277  1448             //          : //~~~~~~~
1278  1449             //          : call();
1279  1450             // Notes    : Calls the specified function, the arguments to the called function are from the stack. The stacked
1280  1451             //          : parameters are consumed and the stack pointer is altered to match the number of arguments that were
1281  1452             //          : consumed.
1282  1453             //          : value: If the called function returns a value then it is available.
1283  1454   
1284  1455             func exec("func","argcnt"), 1;                  // exec a function using stacked parameters (parameters remain)
1285  1456             // Syntax   : exec("func","argcnt");
1286  1457             // Usage    : Push(50); // set some arbitrary values on the stack
1287  1458             //          : push(50);
1288  1459             //          : push(10);
1289  1460             //          : push(YELLOW);
1290  1461             //          : //~~~~~~~
1291  1462             //          : exec(gfx_Circle,4); // exec the circle function using the stacked parameters
1292  1463             // Notes    : Calls the specified function, passing the arguments to the called function from the stack. The stack and
1293  1464             //          : stack pointer are not altered.
1294  1465             //          : functionPtr A pointer to a function which will utilise the stacked arguments. argCount The count of
1295  1466             //          : arguments on the stack that are to be passed to the function call.
1296  1467             //          : The arguments can be a variable, array element, expression or constant.
1297  1468   
1298  1469             //==============================================//
1299  1470             // size modifier                                //
1300  1471             //==============================================//
1301  1472   
1302  1473             func iterator("offset"), 0;                     // set the iterator size for ++/-- (same as pokeW(INCVAL, n);
1303  1474             // Syntax   : iterator("offset");
1304  1475             // Usage    : iterator(arg);
1305  1476             // Notes    :
1306  1477   
1307  1478             //==============================================//
1308  1479             // string and character size function           //
1309  1480             //==============================================//
1310  1481   
1311  1482             func strlen("pointer"), 1;                      // return length of a string in character units
1312  1483             // Syntax   : strlen("pointer");
1313  1484             // Usage    : var := strlen(Str);
1314  1485             // Notes    : strlen returns the length of a zero terminated string in character units. Note that any string constants
1315  1486             //          : declared in your program are automatically terminated with a zero as an end marker by the compiler. Any
1316  1487             //          : string that you create in the DATA section or MEM section must have a zero added as a terminator for this
1317  1488             //          : function to work correctly.
1318  1489             //          : pointer: The pointer to a zero (0x00) terminated string.
1319  1490             //          : Returns the length of a string in character units.
1320  1491   
1321  1492             func charwidth("char"), 1;                          // return width of a character in pixel units
1322  1493             // Syntax   : charwidth("char");
1323  1494             // Usage    : txt_FontID(MS_SanSerif8x12); // select this font
1324  1495             //          : w := charwidth('W');  // get a characters width
1325  1496             // Notes    : charwidth is used to calculate the width in pixel units for a string, based on the currently selected
1326  1497             //          : font. The font can be proportional or mono-spaced. If the total width of the string exceeds 255 pixel
1327  1498             //          : units, the function will return the 'wrapped' (modulo 8) value.
1328  1499             //          : char: The ascii character for the width calculation.
1329  1500             //          : Returns the width of a single character in pixel units.
1330  1501   
1331  1502             func charheight("char"), 1;                         // return height of a character in pixel units
1332  1503             // Syntax   : charheight("char");
1333  1504             // Usage    : txt_FontID(MS_SanSerif8x12); // select this font
1334  1505             //          : w := charheight('W'); // get a characters width
1335  1506             // Notes    : charheight is used to calculate the height in pixel units for a string, based on the currently selected
1336  1507             //          : font. The font can be proportional or mono-spaced.
1337  1508             //          : char: The ascii character for the height calculation.
1338  1509             //          : Returns the height of a single character in pixel units.
1339  1510   
1340  1511             func strwidth("pointer"), 1;                    // return width of a string in pixel units
1341  1512             // Syntax   : strwidth("pointer");
1342  1513             // Usage    : var := strwidth(Str);
1343  1514             // Notes    : strwidth returns the width of a zero terminated string in pixel units. Note that any string constants
1344  1515             //          : declared in your program are automatically terminated with a zero as an end marker by the compiler. Any
1345  1516             //          : string that you create in the DATA section or MEM section must have a zero added as a terminator for this
1346  1517             //          : function to work correctly.
1347  1518             //          : pointer: The pointer to a zero (0x00) terminated string.
1348  1519             //          : Returns the width of a string in pixel units.
1349  1520   
1350  1521             func strheight(), 1;                            // return height of a string in pixel units
1351  1522             // Syntax   : strheight(Str);
1352  1523             // Usage    : var := strheight();
1353  1524             // Notes    : strheight returns the height of a zero terminated string in pixel units. The strwidth function must be
1354  1525             //          : called first which makes available width and height. Note that any string constants declared in your
1355  1526             //          : program are automatically terminated with a zero as an end marker by the compiler. Any string that you
1356  1527             //          : create in the DATA section or MEM section must have a zero added as a terminator for this function to work
1357  1528             //          : correctly.
1358  1529             //          : Returns the height of a string in pixel units.
1359  1530   
1360  1531             //==============================================//
1361  1532             // extended functions                           //
1362  1533             //==============================================//
1363  1534   
1364  1535             func EVE_SP(), 1;                               // current EVE stack pointer
1365  1536             // Syntax   : EVE_SP();
1366  1537             // Usage    : var := EVE_SP();
1367  1538             // Notes    : returns the EVE stack pointer, useful for fault finding
1368  1539             //          : and checking for stack limits. Eve stack is 0x300 to 0x3FF
1369  1540             //          : Your application should not take stack above 0x3C0 to allow
1370  1541             //          : room for internal use.
1371  1542   
1372  1543   
1373  1544             //==============================================//
1374  1545             // Single parameter short-cuts                  //
1375  1546             // for the txt_Set functions                    //
1376  1547             //==============================================//
1377  1548   
1378  1549             func txt_FGcolour("colour"), 0;                 // 0  text foreground colour
1379  1550             // Syntax   : txt_FGcolour("colour")
1380  1551             // Usage    : txt_FGcolour(colr);
1381  1552             // Notes    : Change text foreground color
1382  1553   
1383  1554             func txt_BGcolour("colour"), 0;                 // 1  text background colour
1384  1555             // Syntax   : txt_BGcolour("colour");
1385  1556             // Usage    : txt_BGcolour(colr);
1386  1557             // Notes    : Change text background color
1387  1558   
1388  1559             func txt_FontID("id"), 0;                       // 2  text font ID (0 = system font)
1389  1560             // Syntax   : txt_FontID("id");
1390  1561             // Usage    : txt_FontID(font_num);
1391  1562             // Notes    : Set font type
1392  1563   
1393  1564             func txt_Width("multiplier"), 0;                // 3  text width multiplier
1394  1565             // Syntax   : txt_Width("multiplier");
1395  1566             // Usage    : txt_Width(arg);
1396  1567             // Notes    : Multiply the text width by x times.
1397  1568   
1398  1569             func txt_Height("multiplier"), 0;               // 4  text height multiplier
1399  1570             // Syntax   : txt_Height("multiplier");
1400  1571             // Usage    : txt_Height(arg);
1401  1572             // Notes    :  Multiply the text height by x times.
1402  1573   
1403  1574             func txt_Xgap("pixelcount"), 0;                 // 5  text gap between characters
1404  1575             // Syntax   : txt_Xgap("pixelcount");
1405  1576             // Usage    : txt_Xgap(arg);
1406  1577             // Notes    : Set gap between two consecutive characters
1407  1578   
1408  1579             func txt_Ygap("pixelcount"), 0;                 // 6  text gap between lines
1409  1580             // Syntax   : txt_Ygap("pixelcount");
1410  1581             // Usage    : txt_Ygap(arg);
1411  1582             // Notes    : Set gap between two consecutive rows of characters
1412  1583   
1413  1584             func txt_Delay("millisecs"), 0;                 // 7  text printing delay factor
1414  1585             // Syntax   : txt_Delay("millisecs");
1415  1586             // Usage    : txt_Delay(arg);
1416  1587             // Notes    : Text printing delay
1417  1588   
1418  1589             func txt_Opacity("mode"), 0;                    // 8  text OPAQUE or TRANSPARENT
1419  1590             // Syntax   : txt_Opacity("mode");
1420  1591             // Usage    : txt_Opacity(arg);
1421  1592             // Notes    : Set text to be opaque or transparent
1422  1593             //          : 0 for opaque
1423  1594             //          : 1 for transparent
1424  1595   
1425  1596             func txt_Bold("mode"), 0;                       // 9  text bold ON/OFF
1426  1597             // Syntax   : txt_Bold("mode");
1427  1598             // Usage    : txt_Bold(arg);
1428  1599             // Notes    : Set bold text on or off
1429  1600             //          : 0 bold off
1430  1601             //          : 1 bold on
1431  1602   
1432  1603             func txt_Italic("mode"), 0;                     // 10 text italic ON/OFF
1433  1604             // Syntax   : txt_Italic("mode");
1434  1605             // Usage    : txt_Italic(arg);
1435  1606             // Notes    : Set Itallic text on or off
1436  1607             //          : 0 Itallic off
1437  1608             //          : 1 Itallic on
1438  1609   
1439  1610             func txt_Inverse("mode"), 0;                    // 11 text inverse ON/OFF
1440  1611             // Syntax   : txt_Inverse("mode");
1441  1612             // Usage    : txt_Inverse(arg);
1442  1613             // Notes    : Set inverse text on or off
1443  1614             //          : 0 Inverse off
1444  1615             //          : 1 Inverse on
1445  1616   
1446  1617             func txt_Underline("mode"), 0;                  // 12 text underline ON/OFF
1447  1618             // Syntax   : txt_Underline("mode");
1448  1619             // Usage    : txt_Underline(arg);
1449  1620             // Notes    : Set Underline text on or off
1450  1621             //          : 0 Underlining off
1451  1622             //          : 1 Underlining on
1452  1623   
1453  1624             func txt_Attributes("value"), 0;                // 13 text combined bold|italic|inverse|underline
1454  1625             // Syntax   : txt_Attributes("value");
1455  1626             // Usage    : txt_Attributes(arg);
1456  1627             // Notes    : text combined bold|italic|inverse|underline, enabled or disabled simultaneously
1457  1628             //          : 0 : bold|italic|inverse|underline disabled
1458  1629   
1459  1630             func _1E(), 0;                                  // 14 text reserved
1460  1631             func _1F(), 0;                                  // 15 text reserved
1461  1632   
1462  1633             //==============================================//
1463  1634             // Single parameter short-cuts                  //
1464  1635             // for the gfx_Set functions                    //
1465  1636             //==============================================//
1466  1637   
1467  1638             func gfx_PenSize("mode"), 0;                    // 0  graphics pen size, SOLD or OUTLINE
1468  1639             // Syntax   : gfx_PenSize("mode");
1469  1640             // Usage    : gfx_PenSize("mode");
1470  1641             // Notes    : Set pen size.
1471  1642             //          : 0 Solid object
1472  1643             //          : 1 Outline object
1473  1644   
1474  1645             func gfx_BGcolour("colour"), 0;                 // 1  graphics background colour
1475  1646             // Syntax   : gfx_BGcolour("colour");
1476  1647             // Usage    : gfx_BGcolour(colr");
1477  1648             // Notes    : Sets background color of the screen
1478  1649             //          : value = 0 to 0xFFFF, Black to White
1479  1650   
1480  1651             func gfx_ObjectColour("colour"), 0;             // 2  graphics object colour
1481  1652             // Syntax   : gfx_ObjectColour("colour");
1482  1653             // Usage    : gfx_ObjectColour(colr);
1483  1654             // Notes    : Sets the Object colour used in various functions
1484  1655             //          : value = 0 to 0xFFFF, Black to White
1485  1656             //          : LineTo(,,); LineRel(,,); BoxTo(,,); Dot(); etc.
1486  1657   
1487  1658             func gfx_Clipping("mode"), 0;                   // 3  graphics clipping ON/OFF
1488  1659             // Syntax   : gfx_Clipping("mode");
1489  1660             // Usage    : gfx_Clipping("mode");
1490  1661             // Notes    : Set clipping mode
1491  1662             //          : 0 : Clipping disabled
1492  1663             //          : 1 : Clipping enabled
1493  1664   
1494  1665             func gfx_TranparentColour("colour"), 0;         // 4  graphics image transparent mask colour
1495  1666             // Syntax   : gfx_TranparentColour("colour");
1496  1667             // Usage    : gfx_TranparentColour("colr");
1497  1668             // Notes    : Sets Bitmap, Image or Animation Transparency Colour
1498  1669             //          : value = 0 to 0xFFFF Black to White
1499  1670   
1500  1671             func gfx_Tranparency("mode"), 0;                // 5  graphics image transparent mode ON/OFF
1501  1672             // Syntax   : gfx_Tranparency("mode");
1502  1673             // Usage    : gfx_Tranparency("mode");
1503  1674             // Notes    : Enables/Disables the Transparency feature
1504  1675             //          : 0 : Transparency disabled
1505  1676             //          : 1 : Transparency enabled
1506  1677   
1507  1678             func gfx_FrameDelay("milliseconds"), 0;         // 6  graphics animation frame delay
1508  1679             // Syntax   : gfx_FrameDelay("milliseconds");
1509  1680             // Usage    : gfx_FrameDelay(arg);
1510  1681             // Notes    : Sets the Video/Animation clip inter-frame delay for uSD_Video function.
1511  1682             //          : This setting will over-ride the embedded frame delay of the clip. After the event, the setting will autodisable, and
1512  1683             //          : if further inter-frame delays need overriding the setting must be reissued.
1513  1684             //          : This function will not control frame delays for a image control, refer to image control.
1514  1685             //          : value = 0 to 255 ms
1515  1686   
1516  1687             func gfx_ScreenMode("mode"), 0;                 // 7  graphics orientation LANDSCAPE, LANDSCAPE_R, PORTRAIT, PORTRAIT_R
1517  1688             // Usage    : gfx_ScreenMode(LANDSCAPE);
1518  1689             // Notes    : Set display orientation
1519  1690             //          : value = 1 : LANDSCAPE
1520  1691             //          : value = 2 : LANDSCAPE_R (Rotated)
1521  1692             //          : value = 3 : PORTRAIT
1522  1693             //          : value = 4 : PORTRAIT_R (Rotated)
1523  1694   
1524  1695             func gfx_OutlineColour("colour"), 0;            // 8  graphics rectangle/circle outline colour
1525  1696             // Syntax   : gfx_OutlineColour("colour");
1526  1697             // Usage    : gfx_OutlineColour(colr");
1527  1698             // Notes    : Sets the solid Rectangle or Circle objects outline colour.
1528  1699             //          : value = 0 : Disables this feature
1529  1700             //          : value = 1 to 0xFFFF : is the effective range
1530  1701   
1531  1702             func gfx_Contrast("value"), 0;                  // 9  graphics hardware contrast value 0-16 (0=off) *** only on internal driver devices
1532  1703             // Usage    : gfx_Contrast(val);
1533  1704             // Notes    : Set the display contrast
1534  1705             //          : 0 Display in low power mode. Display retains its contents in low power mode
1535  1706             //          : 1-16 Display on 1 = lowest, 16 = highest
1536  1707   
1537  1708             func gfx_LinePattern("value"), 0;               // 10 graphics line draw tesselation pattern (16 linear bits, 1=pixel off)
1538  1709             // Syntax   : gfx_LinePattern("value");
1539  1710             // Usage    : gfx_LinePattern(val);
1540  1711             // Notes    : Sets the line draw pattern for line drawing. If set to zero, lines are solid, else eac '1' bit represents
1541  1712             //          : a pixel that is turned off.
1542  1713             //          : 0 bits for pixels on
1543  1714             //          : 1 bits for pixels off
1544  1715   
1545  1716             func gfx_ColourMode("mode"), 0;                 // 11 graphics colour mode COLOUR8 or COLOUR16 (default colour 16)
1546  1717             // Syntax   : gfx_ColourMode("mode");
1547  1718             // Usage    : gfx_ColourMode(mod);
1548  1719             // Notes    : Set Graphics Colour mode
1549  1720             //          : COLOUR8  : 8bit colours
1550  1721             //          : COLOUR16 : 16bit colours
1551  1722   
1552  1723             //==============================================//
1553  1724             func _2C(), 0;                                  // 12 graphics  reserved
1554  1725             func _2D(), 0;                                  // 13 graphics  reserved
1555  1726             func _2E(), 0;                                  // 14 graphics  reserved
1556  1727             func _2F(), 0;                                  // 15 graphics  reserved
1557  1728             //==============================================//
1558  1729   
1559  1730   
1560  1731             //==============================================//
1561  1732             // generic constants                            //
1562  1733             //==============================================//
1563  1734             #CONST
1564  1741             #END
1565  1742   
1566  1743             //==============================================//
1567  1744             // joystick() function return constants         //
1568  1745             //==============================================//
1569  1746             #CONST
1570  1753             #END
1571  1754   
1572  1755             //==============================================//
1573  1756             // spi_Init(...)  mode arguments                //
1574  1757             //==============================================//
1575  1758             #CONST
1576  1768             #END
1577  1769   
1578  1770             //==============================================//
1579  1771             //Pin related constants                         //
1580  1772             //==============================================//
1581  1773             #CONST
1582  1784             #END
1583  1785   
1584  1786             //==============================================//
1585  1787             //gfx_Set() related constants                   //
1586  1788             //==============================================//
1587  1789             #CONST
1588  1802             #END
1589  1803   
1590  1804   
1591  1805             #CONST
1592  1816             #END
1593  1817   
1594  1818             //==============================================//
1595  1819             //txt_Set() related constants                   //
1596  1820             //==============================================//
1597  1821             #CONST
1598  1836             #END
1599  1837   
1600  1838             //==============================================//
1601  1839             //txt_Set() related arguments                   //
1602  1840             //==============================================//
1603  1841             #CONST
1604  1853             #END
1605  1854   
1606  1855   
1607  1856             //==============================================//
1608  1857             // Memory MAP                                   //
1609  1858             // system BYTE variables accesible with         //
1610  1859             // peekB and pokeB                              //
1611  1860             //==============================================//
1612  1861             #CONST
1613  1897             #END
1614  1898   
1615  1899   
1616  1900             //==============================================//
1617  1901             // system WORD variables accesible with peekW   //
1618  1902             // and pokeW or pointer access                  //
1619  1903             //==============================================//
1620  1904             #CONST
1621  1950             #END
1622  1951   
1623  1952             //==============================================//
1624  1953             // bit constants for SYS_FLAGS1                 //
1625  1954             //==============================================//
1626  1955             #CONST //SYS_FLAGS1
1627  1972             #END
1628  1973   
1629  1974             //==============================================//
1630  1975             // bit constants for SYS_FLAGS2                 //
1631  1976             //==============================================//
1632  1977             #CONST // SYS_FLAGS2
1633  1994             #END
1634  1995   
1635  1996   
1636  1997             //==============================================//
1637  1998             // EVE User Resources                           //
1638  1999             //==============================================//
1639  2000             #CONST
1640  2004             #END
1641  2005   
1642  2006             //------------------------------------------------------------------------------
1643  2007             //------------------------------------------------------------------------------
1644  2008             //------------------------------------------------------------------------------
1645  2009             //------------------------------------------------------------------------------
1646  2010             //------------------------------------------------------------------------------
1647  2011   
1648  2012   
1649  2013   
1650  2014   
1651  2015   
1652  2016   
1653  2017   
1654  2018   
1655  2019   
1656  2020   
1657  0002   
file C:\Program Files\4D Labs\4D Workshop 3 IDE\include\4DGL_16bitColours.fnc

1658  0003             #inherit "4DGL_16bitColours.fnc"
1659  0003             #inherit "4DGL_16bitColours.fnc"
1660  0004             */
1661  0005   
1662  0006   
1663  0007   
1664  0008             #CONST
1665  0149             #END
1666  0150   
file C:\Documents and Settings\simon\Bureaublad\mugDisplay\mugDisplay\mugDisplayUtils.fnc

1667  0004             #inherit "mugDisplayUtils.fnc"
1668  0004             #inherit "mugDisplayUtils.fnc"
1669  0001             var lastError := "";
1670  0002   
1671  0003             func setError(var err)
1672  0004                 lastError := err;
1673  0005             endfunc
1674  0006   
1675  0007             func getError()
1676  0008                 return lastError;
1677  0009             endfunc
file C:\Documents and Settings\simon\Bureaublad\mugDisplay\mugDisplay\mugDisplayCommunication.fnc

1678  0005             #inherit "mugDisplayCommunication.fnc"
1679  0005             #inherit "mugDisplayCommunication.fnc"
1680  0001             #constant SERIAL_BUFFER_SIZE    128
1681  0001             #constant SERIAL_BUFFER_SIZE    128
1682  0002             #constant MSG_BUFFER_SIZE       32
1683  0002             #constant MSG_BUFFER_SIZE       32
1684  0003   
1685  0004             var serial_buffer_ptr := 0;
1686  0005             var serial_buffer[SERIAL_BUFFER_SIZE];
1687  0006   
1688  0007             func getStringPtr()
1689  0008                 return serial_buffer + serial_buffer_ptr - 1;
1690  0009             endfunc
1691  0010   
1692  0011             func hasNextChar()
1693  0012                 if (com_Count() > 1) // ignore checksum (last byte)
1694  0013                     return TRUE;
1695  0014                 endif
1696  0015                 return FALSE;
1697  0016             endfunc
1698  0017   
1699  0018             func hasChars()
1700  0019                 return com_Count() - 1; // ignore checksum
1701  0020             endfunc
1702  0021   
1703  0022             func getNextChar()
1704  0023                 serial_buffer_ptr++;
1705  0024                 return serin();
1706  0025             endfunc
1707  0026   
1708  0027             func verifySerialBufferContents()
1709  0028                 var bytes;
1710  0029   
1711  0030                 bytes := com_Count();
1712  0031                 if (bytes <= 0)
1713  0032                     setError("Zero package");
1714  0033                     return FALSE;
1715  0034                 endif
1716  0035   
1717  0036                 if (com_Checksum())
1718  0037                     txt_MoveCursor(6, 0);
1719  0038                     setError("Checksum failed");
1720  0039                     return FALSE;
1721  0040                 endif
1722  0041   
1723  0042                 return TRUE;
1724  0043             endfunc
1725  0044   
1726  0045             func resetSerialBuffer()
1727  0046                 serial_buffer_ptr := 0;
1728  0047                 com_Init(serial_buffer, 0, '$');
1729  0048             endfunc
1730  0049   
1731  0050             func sendAck()
1732  0051                 to(COM0); print("OK\n");
1733  0052             endfunc
1734  0053   
1735  0054             func sendNAck(var errMsg)
1736  0055                 to(COM0); print("ERR:", [STR] errMsg, "\n");
1737  0056             endfunc
1738  0057   
1739  0058             func initCommunication(var baudrate)
1740  0059                 resetSerialBuffer();
1741  0060                 if (baudrate == 0)
1742  0061                     repeat
1743  0062                         baudrate := com_AutoBaud(500);
1744  0063                         txt_MoveCursor(2, 0);
1745  0064                         print("Waiting 'U'...");
1746  0065                     until (baudrate);
1747  0066                     print("\nOk");
1748  0067                     pause(500);
1749  0068                     gfx_Cls();
1750  0069                 else
1751  0070                     setbaud(baudrate);
1752  0071                 endif
1753  0072                 sendAck();
1754  0073             endfunc
file C:\Documents and Settings\simon\Bureaublad\mugDisplay\mugDisplay\mugDisplayDisplay.fnc

1755  0006             #inherit "mugDisplayDisplay.fnc"
1756  0006             #inherit "mugDisplayDisplay.fnc"
1757  0001             #constant scroll_blit_sector       $ 0x0020, 0x0000       /* offset 0xC400 */
1758  0001             #constant scroll_blit_sector       $ 0x0020, 0x0000       /* offset 0xC400 */
1759  0002             #constant selected_message_sector  $ 0x0010, 0x0000       /* offset selected message */
1760  0002             #constant selected_message_sector  $ 0x0010, 0x0000       /* offset selected message */
1761  0003   
1762  0004             #CONST
1763  0015             #END
1764  0016   
1765  0017   0007 var selection_area_properties[] := [0, 118, 127, 9, GREEN, BLACK, 15, 0, 1, 0];
1766  00071767  00081768  00091769  000A1770  000B1771  000C1772  000D1773  000E1774  000F1775  00101776  00111777  00121778  00131779  00141780  00151781  00161782  00171783  00181784  00191785  001A1786  0018   001B var message_window_properties[] := [0, 24, 127, 90, BLUE, BLACK, 13, 0, 0, 1];
1787  001B1788  001C1789  001D1790  001E1791  001F1792  00201793  00211794  00221795  00231796  00241797  00251798  00261799  00271800  00281801  00291802  002A1803  002B1804  002C1805  002D1806  002E1807  0019   002F var power_icon_properties[] := [106, 2, ICON_WIDTH, ICON_HEIGHT, 0, BLACK];
1808  002F1809  00301810  00311811  00321812  00331813  00341814  00351815  00361816  00371817  00381818  00391819  003A1820  0020   003B var signal_icon_properties[] := [62, 2, ICON_WIDTH, ICON_HEIGHT, 0, BLACK];
1821  003B1822  003C1823  003D1824  003E1825  003F1826  00401827  00411828  00421829  00431830  00441831  00451832  00461833  0021   0047 var transmission_icon_properties[] := [84, 2, ICON_WIDTH, ICON_HEIGHT, 0, BLACK];
1834  00471835  00481836  00491837  004A1838  004B1839  004C1840  004D1841  004E1842  004F1843  00501844  00511845  00521846  0022   
1847  0023             var selected_message_buffer[MSG_BUFFER_SIZE];
1848  0024             var selected_message_length;
1849  0025             var selected_message;
1850  0026             var selected_message_offset;
1851  0027   
1852  0028             func displayIconAtPosition(var sectHi, var sectLo, var x, var y, var frame)
1853  0029                 media_SetSector(sectHi, sectLo);
1854  0030                 media_VideoFrame(x, y, frame);
1855  0031             endfunc
1856  0032   
1857  0033             func clearArea(var x, var y, var w, var h, var fg_colour, var bg_colour)
1858  0034                 var pixels;
1859  0035   
1860  0036                 gfx_Clipping(ON);
1861  0037                 gfx_ClipWindow(x, y, x+w, y+h);
1862  0038   
1863  0039                 pixels := gfx_FocusWindow();
1864  0040   
1865  0041                 disp_BlitPixelFill(bg_colour, pixels);
1866  0042                 gfx_Clipping(OFF);
1867  0043             endfunc
1868  0044   
1869  0045             func displaySplashScreen(var sectHiWord, var sectLoWord, var x, var y)
1870  0046                 var n := 0;
1871  0047   
1872  0048                 gfx_Contrast(1);
1873  0049   
1874  0050                 media_SetSector(sectHiWord, sectLoWord);
1875  0051                 media_Image(x, y);
1876  0052   
1877  0053                 while(n++ < 16)
1878  0054                     gfx_Contrast(n);                                // brighten up count 1 to 16
1879  0055                     pause(50);
1880  0056                 wend
1881  0057   
1882  0058                 pause(SPLASH_SCREEN_DELAY);
1883  0059   
1884  0060                 while(--n)
1885  0061                     gfx_Contrast(n);
1886  0062                     pause(80);
1887  0063                 wend
1888  0064   
1889  0065                 gfx_Cls();
1890  0066                 gfx_Contrast(16);
1891  0067             endfunc
1892  0068   
1893  0069             func text_wrap(var str, var bfr, var offset)
1894  0070                 var txtStr, i, chars, width;
1895  0071   
1896  0072                 txtStr := str + offset;
1897  0073                 chars := strlen(str);
1898  0074                 width := 0;
1899  0075   
1900  0076                 for (i:=0; i<10; i++, offset++)
1901  0077                     if (chars == offset)
1902  0078                         offset := 0;
1903  0079                         break;
1904  0080                     endif
1905  0081                     bfr[i] := txtStr[i];
1906  0082                 next
1907  0083   
1908  0084                 bfr[i] := 0x00;
1909  0085   
1910  0086                 return offset;
1911  0087   
1912  0088             endfunc
1913  0089   
1914  0090             func print_message(var str, var area)
1915  0091                 var i, len;
1916  0092                 var found_delim;
1917  0093                 var found_name;
1918  0094   
1919  0095                 found_delim := FALSE;
1920  0096                 found_name := FALSE;
1921  0097   
1922  0098                 len := (strlen(str)+1) / 2;
1923  0099                 for (i:=0; i<len; i++)
1924  0100                     var c1, c2;
1925  0101   
1926  0102                     c1 := str[i] & 0x00ff;
1927  0103                     c2 := (str[i] & 0xff00) >> 8;
1928  0104   
1929  0105                     if (found_delim == FALSE)
1930  0106                         if (c2 == '/')
1931  0107                             found_delim := TRUE;
1932  0108                             found_name := TRUE;
1933  0109                             txt_FGcolour(RED);
1934  0110                             txt_Bold(1);
1935  0111                             continue;
1936  0112                         else if (c2 == '*')
1937  0113                             found_delim := TRUE;
1938  0114                             found_name := TRUE;
1939  0115                             txt_FGcolour(YELLOW);
1940  0116                             txt_Bold(1);
1941  0117                             continue;
1942  0118                         else if (c2 == '^')
1943  0119                             found_delim := TRUE;
1944  0120                             found_name := TRUE;
1945  0121                             txt_FGcolour(PURPLE);
1946  0122                             txt_Bold(1);
1947  0123                             continue;
1948  0124                         endif
1949  0125                     endif
1950  0126   
1951  0127                     if (found_name && c1 == ' ')
1952  0128                         txt_FGcolour(area[FG_COLOUR]);
1953  0129                         txt_Bold(area[TEXT_TYPE_BOLD]);
1954  0130                         found_name := FALSE;
1955  0131                     endif
1956  0132   
1957  0133                     putch(c1);
1958  0134   
1959  0135                     if (found_name && c2 == ' ')
1960  0136                         txt_FGcolour(area[FG_COLOUR]);
1961  0137                         txt_Bold(area[TEXT_TYPE_BOLD]);
1962  0138                         found_name := FALSE;
1963  0139                     endif
1964  0140   
1965  0141                     putch(c2);
1966  0142                 next
1967  0143             endfunc
1968  0144   
1969  0145             func display_text_in_area(var str, var area)
1970  0146                 var lines;
1971  0147   
1972  0148                 clearArea(@area);
1973  0149   
1974  0150                 gfx_Clipping(ON);
1975  0151                 gfx_ClipWindow(area[X],
1976  0152                                area[Y],
1977  0153                                area[X] + area[WIDTH],
1978  0154                                area[Y] + area[HEIGHT]);
1979  0155   
1980  0156                 txt_MoveCursor(area[TEXT_LINE], area[TEXT_COL]);
1981  0157                 txt_Bold(area[TEXT_TYPE_BOLD]);
1982  0158                 txt_FGcolour(area[FG_COLOUR]);
1983  0159                 txt_BGcolour(area[BG_COLOUR]);
1984  0160   
1985  0161                 print_message(str, area);
1986  0162                 lines := 1;
1987  0163   
1988  0164                 gfx_Clipping(OFF);
1989  0165   
1990  0166                 return lines;
1991  0167             endfunc
1992  0168   
1993  0169             func scroll_text_in_selection_area()
1994  0170                 var private delay := 5;
1995  0171                 var len;
1996  0172   
1997  0173                 len := strlen(selected_message);
1998  0174   
1999  0175                 if (len < 17)
2000  0176                     return;
2001  0177                 endif
2002  0178   
2003  0179                 if (delay == 0)
2004  0180                     if (++selected_message_offset == len-1)
2005  0181                         selected_message_offset := 0;
2006  0182                         delay := 5;
2007  0183                     endif
2008  0184   
2009  0185                     if (selected_message_offset <= (strlen(selected_message) + 1) / 2)
2010  0186                         display_text_in_area(selected_message+selected_message_offset, selection_area_properties);
2011  0187                     endif
2012  0188                 else
2013  0189                     delay--;
2014  0190                 endif
2015  0191             endfunc
2016  0192   
2017  0193             func display_selection_text(var str, var offset)
2018  0194                 selected_message := str;
2019  0195                 selected_message_offset := offset;
2020  0196   
2021  0197                 if (selected_message_offset <= (strlen(selected_message) / 2) + 1)
2022  0198                     display_text_in_area(selected_message+selected_message_offset, selection_area_properties);
2023  0199                 endif
2024  0200             endfunc
2025  0201   
2026  0202             func display_selection_text_copy(var str, var offset)
2027  0203                 var len, i;
2028  0204   
2029  0205                 len := (strlen(str) + 1) / 2;
2030  0206   
2031  0207                 for (i:=0; i<MSG_BUFFER_SIZE; i++)
2032  0208                     if (i < len)
2033  0209                         selected_message_buffer[i] := str[i];
2034  0210                     else
2035  0211                         selected_message_buffer[i] := 0x00;
2036  0212                     endif
2037  0213                 next
2038  0214   
2039  0215                 display_selection_text(selected_message_buffer, offset);
2040  0216             endfunc
2041  0217   
2042  0218             func _write_str_to_window(var msg, var area)
2043  0219                 var pixels;
2044  0220                 var width, height;
2045  0221   
2046  0222                 width := strwidth(msg);
2047  0223                 height := strheight() + 3;
2048  0224   
2049  0225                 gfx_Clipping(ON);
2050  0226                 gfx_ClipWindow(area[X],
2051  0227                                area[Y] + height,
2052  0228                                area[X] + area[WIDTH],
2053  0229                                area[Y] + area[HEIGHT]);
2054  0230   
2055  0231                 gfx_FocusWindow();
2056  0232                 media_SetSector(scroll_blit_sector);
2057  0233                 pixels := disp_BlitPixelsToMedia();
2058  0234   
2059  0235                 display_text_in_area(msg, area);
2060  0236   
2061  0237                 gfx_ClipWindow(area[X],
2062  0238                                area[Y],
2063  0239                                area[X] + area[WIDTH],
2064  0240                                area[Y] + area[HEIGHT] - height);
2065  0241   
2066  0242                 pixels := gfx_FocusWindow();
2067  0243                 media_SetSector(scroll_blit_sector);
2068  0244                 disp_BlitPixelsFromMedia(pixels);
2069  0245                 gfx_Clipping(OFF);
2070  0246             endfunc
2071  0247   
2072  0248             func write_str_to_window(var str, var area)
2073  0249                 var lines;
2074  0250   
2075  0251                 if (area[TEXT_WRAP])
2076  0252                     var offset;
2077  0253                     var bfr[11];
2078  0254   
2079  0255                     offset := text_wrap(str, bfr, offset);
2080  0256   
2081  0257                     repeat
2082  0258                         _write_str_to_window(bfr, area);
2083  0259                         offset := text_wrap(str, bfr, offset);
2084  0260                         lines++;
2085  0261                     until (offset == 0);
2086  0262   
2087  0263                 else
2088  0264                     lines := _write_str_to_window(str, area);
2089  0265                 endif
2090  0266   
2091  0267                 return lines;
2092  0268             endfunc
2093  0269   
2094  0270             func write_message(var str)
2095  0271                 write_str_to_window(str, message_window_properties);
2096  0272             endfunc
2097  0273   
2098  0274             func write_selected_message()
2099  0275                 write_str_to_window(selected_message, message_window_properties);
2100  0276                 clearArea(@selection_area_properties);
2101  0277             endfunc
2102  0278   
2103  0279             func initScreenLayout()
2104  0280                 gfx_Hline(3+ICON_HEIGHT, 0, 127, GREEN);
2105  0281                 gfx_Hline(116, 0, 127, GREEN);
2106  0282                 clearArea(@message_window_properties);
2107  0283                 clearArea(@selection_area_properties);
2108  0284   
2109  0285                 txt_Height(5);
2110  0286                 txt_Width(4);
2111  0287                 txt_MoveCursor(1, 0);
2112  0288                 print(" MUG");
2113  0289                 txt_Height(1);
2114  0290                 txt_Width(1);
2115  0291             endfunc
2116  0007             //==========================================================================
2117  0008   
2118  0009             #constant DISPLAY_SPLASH_SCREEN     := FALSE
2119  0009             #constant DISPLAY_SPLASH_SCREEN     := FALSE
2120  0010             #constant BAUD_AUTOBAUD             := 0
2121  0010             #constant BAUD_AUTOBAUD             := 0
2122  0011             #constant SERIAL_BAUDRATE           BAUD_19200
2123  0011             #constant SERIAL_BAUDRATE           BAUD_19200
2124  0012   
2125  0013             #constant ANIMATION_TIMEOUT         := 100
2126  0013             #constant ANIMATION_TIMEOUT         := 100
2127  0014             #constant TXT_SCROLL_TIMEOUT        := 350
2128  0014             #constant TXT_SCROLL_TIMEOUT        := 350
2129  0015             #constant SPLASH_SCREEN_DELAY       := 150
2130  0015             #constant SPLASH_SCREEN_DELAY       := 150
2131  0016             #constant ICON_WIDTH                := 20
2132  0016             #constant ICON_WIDTH                := 20
2133  0017             #constant ICON_HEIGHT               := 18
2134  0017             #constant ICON_HEIGHT               := 18
2135  0018   
2136  0019             #constant ANIMATION_TIMER           TIMER1
2137  0019             #constant ANIMATION_TIMER           TIMER1
2138  0020             #constant INIT_ANIMATION_TIMER      $ *ANIMATION_TIMER := ANIMATION_TIMEOUT
2139  0020             #constant INIT_ANIMATION_TIMER      $ *ANIMATION_TIMER := ANIMATION_TIMEOUT
2140  0021             #constant RESET_ANIMATION_TIMER     $ INIT_ANIMATION_TIMER
2141  0021             #constant RESET_ANIMATION_TIMER     $ INIT_ANIMATION_TIMER
2142  0022             #constant ANIMATION_TIMER_TIMEOUT   $ !(*ANIMATION_TIMER)
2143  0022             #constant ANIMATION_TIMER_TIMEOUT   $ !(*ANIMATION_TIMER)
2144  0023   
2145  0024             #constant TXT_SCROLL_TIMER           TIMER2
2146  0024             #constant TXT_SCROLL_TIMER           TIMER2
2147  0025             #constant INIT_TXT_SCROLL_TIMER      $ *TXT_SCROLL_TIMER := TXT_SCROLL_TIMEOUT
2148  0025             #constant INIT_TXT_SCROLL_TIMER      $ *TXT_SCROLL_TIMER := TXT_SCROLL_TIMEOUT
2149  0026             #constant RESET_TXT_SCROLL_TIMER     $ INIT_TXT_SCROLL_TIMER
2150  0026             #constant RESET_TXT_SCROLL_TIMER     $ INIT_TXT_SCROLL_TIMER
2151  0027             #constant TXT_SCROLL_TIMER_TIMEOUT   $ !(*TXT_SCROLL_TIMER)
2152  0027             #constant TXT_SCROLL_TIMER_TIMEOUT   $ !(*TXT_SCROLL_TIMER)
2153  0028   
2154  0029             #CONST
2155  0034             #END
2156  0035   
2157  0036             var _transmissionIconDisplayedState := 0;
2158  0037             var _transmissionIconFrame := 0;
2159  0038   
2160  0039             var _powerIconDisplayedState    := 0;
2161  0040             var _powerIconLevel             := 0;
2162  0041   
2163  0042             #CONST
2164  0050             #END
2165  0051   
2166  0052             var _signalIconDisplayedState    := 0;
2167  0053             var _signalIconLevel             := 0;
2168  0054   
2169  0055             #CONST
2170  0062             #END
2171  0063   
2172  0064             #CONST
2173  0068             #END
2174  0069   
2175  0070             #constant NUM_COMMANDS := 9
2176  0070             #constant NUM_COMMANDS := 9
2177  0080   0053                         set_contrast_parser];
2178  00532179  00542180  00552181  00562182  00572183  00582184  00592185  005A2186  005B2187  005C2188  005D2189  005E2190  005F2191  00602192  00612193  00622194  00632195  00642196  00652197  00662198  0081   
2199  0082   
2200  0083   
2201  0084             func checkArgCount(var count)
2202  0085                 if (hasChars() == count)
2203  0086                     return TRUE;
2204  0087                 endif
2205  0088                 return FALSE;
2206  0089             endfunc
2207  0090   
2208  0091             func showIcon(var icon, var show)
2209  0092                 if (icon == ICON_POWER)
2210  0093                     if (show)
2211  0094                         _powerIconDisplayedState := TRUE;
2212  0095                         displayIconAtPosition(power_icon_sector, power_icon_properties[X], power_icon_properties[Y], _powerIconLevel);
2213  0096                     else
2214  0097                         _powerIconDisplayedState := FALSE;
2215  0098                         clearArea(@power_icon_properties);
2216  0099                     endif
2217  0100                 else if (icon == ICON_SIGNAL)
2218  0101                     if (show)
2219  0102                         _signalIconDisplayedState := TRUE;
2220  0103                         displayIconAtPosition(signal_icon_sector, signal_icon_properties[X], signal_icon_properties[Y], _signalIconLevel);
2221  0104                     else
2222  0105                         _signalIconDisplayedState := FALSE;
2223  0106                         clearArea(@signal_icon_properties);
2224  0107                     endif
2225  0108                 else if (icon == ICON_TRANSMISSION)
2226  0109                     if (show)
2227  0110                         _transmissionIconFrame := 0;
2228  0111                         _transmissionIconDisplayedState := TRUE;
2229  0112                     else
2230  0113                         _transmissionIconDisplayedState := FALSE;
2231  0114                         clearArea(@transmission_icon_properties);
2232  0115                     endif
2233  0116                 else
2234  0117                     setError("Unknown icon");
2235  0118                     return FALSE;
2236  0119                 endif
2237  0120   
2238  0121                 return TRUE;
2239  0122             endfunc
2240  0123   
2241  0124             func set_signal_level_parser()
2242  0125                 var level;
2243  0126   
2244  0127                 if (!checkArgCount(1))
2245  0128                     setError("Wrong arg count");
2246  0129                     return FALSE;
2247  0130                 endif
2248  0131   
2249  0132                 level := getNextChar();
2250  0133   
2251  0134                 if (level < 0 || level >= signal_icon_max_idx)
2252  0135                     setError("Invalid parameter");
2253  0136                     return FALSE;
2254  0137                 endif
2255  0138   
2256  0139                 _signalIconLevel := level;
2257  0140                 return showIcon(ICON_SIGNAL, _signalIconDisplayedState);
2258  0141             endfunc
2259  0142   
2260  0143             func set_power_level_parser()
2261  0144                 var level;
2262  0145   
2263  0146                 if (!checkArgCount(1))
2264  0147                     setError("Wrong arg count");
2265  0148                     return FALSE;
2266  0149                 endif
2267  0150   
2268  0151                 level := getNextChar();
2269  0152   
2270  0153                 if (level < 0 || level >= power_icon_max_idx)
2271  0154                     setError("Invalid parameter");
2272  0155                     return FALSE;
2273  0156                 endif
2274  0157   
2275  0158                 _powerIconLevel := level;
2276  0159                 return showIcon(ICON_POWER, _powerIconDisplayedState);
2277  0160             endfunc
2278  0161   
2279  0162             func show_token_parser()
2280  0163                 var icon;
2281  0164                 var show;
2282  0165   
2283  0166                 if (!checkArgCount(2))
2284  0167                     setError("Wrong arg count");
2285  0168                     return FALSE;
2286  0169                 endif
2287  0170   
2288  0171                 icon := getNextChar();
2289  0172                 show := getNextChar();
2290  0173   
2291  0174                 return showIcon(icon, show);
2292  0175             endfunc
2293  0176   
2294  0177             func display_selected_message_parser()
2295  0178                 display_selection_text_copy(getStringPtr(), 0);
2296  0179                 return TRUE;
2297  0180             endfunc
2298  0181   
2299  0182             func write_selected_message_parser()
2300  0183                  write_selected_message();
2301  0184                  return TRUE;
2302  0185             endfunc
2303  0186   
2304  0187             func write_message_parser()
2305  0188                 write_message(getStringPtr());
2306  0189                 return TRUE;
2307  0190             endfunc
2308  0191   
2309  0192             func set_contrast_parser()
2310  0193                 var level;
2311  0194   
2312  0195                 if (!checkArgCount(1))
2313  0196                     setError("Wrong arg count");
2314  0197                     return FALSE;
2315  0198                 endif
2316  0199   
2317  0200                 level := getNextChar();
2318  0201   
2319  0202                 if (level < 0 || level > 16)
2320  0203                     setError("Invalid parameter");
2321  0204                     return FALSE;
2322  0205                 endif
2323  0206   
2324  0207                 gfx_Contrast(level);
2325  0208                 return TRUE;
2326  0209             endfunc
2327  0210   
2328  0211             func parseSerialBuffer()
2329  0212                 var cmd;
2330  0213                 var cntr;
2331  0214                 var retval;
2332  0215   
2333  0216                 cntr := 0;
2334  0217   
2335  0218                 if (!hasNextChar())
2336  0219                     setError("No command");
2337  0220                     return FALSE;
2338  0221                 endif
2339  0222   
2340  0223                 cmd := getNextChar();
2341  0224                 if (cmd == 0 || cmd > NUM_COMMANDS)
2342  0225                     setError("Unknown command");
2343  0226                     return FALSE;
2344  0227                 endif
2345  0228   
2346  0229                 retval := tokenParsers[cmd]();
2347  0230                 return retval;
2348  0231             endfunc
2349  0232   
2350  0233             func waitForMedia()
2351  0234                 gfx_Cls();
2352  0235                 while (media_Init() == 0)                           // initialise and test the uSD card
2353  0236                     txt_FGcolour(RED);
2354  0237                     print("Insert uSD card");
2355  0238                     pause(2000);
2356  0239                     gfx_Cls();
2357  0240                 wend
2358  0241             endfunc
2359  0242   
2360  0243             func main()
2361  0244                 waitForMedia();
2362  0245             #IF (DISPLAY_SPLASH_SCREEN)
2363 !0246                 displaySplashScreen(darth_vader_sector_x_y);
2364  0247             #ENDIF
2365  0248                 initScreenLayout();
2366  0249                 initCommunication(SERIAL_BAUDRATE);
2367  0250                 INIT_ANIMATION_TIMER;
2368  0251                 INIT_TXT_SCROLL_TIMER;
2369  0252   
2370  0253                // pause(500);
2371  0254   
2372  0255                 repeat
2373  0256                     if (com_Error())
2374  0257                         resetSerialBuffer();
2375  0258                         sendNAck("COM_ERROR");
2376  0259                     endif
2377  0260   
2378  0261                     if (com_Full())
2379  0262                         if (verifySerialBufferContents())
2380  0263                             if(parseSerialBuffer())
2381  0264                                 sendAck();
2382  0265                             else
2383  0266                                 sendNAck(getError());
2384  0267                             endif
2385  0268                         else
2386  0269                             sendNAck(getError());
2387  0270                         endif
2388  0271                         resetSerialBuffer();
2389  0272                     endif
2390  0273   
2391  0274                     if (ANIMATION_TIMER_TIMEOUT)
2392  0275                         if (_transmissionIconDisplayedState)
2393  0276                             media_SetSector(transmission_icon_sector);
2394  0277                             media_VideoFrame(transmission_icon_properties[X],transmission_icon_properties[Y], _transmissionIconFrame++);
2395  0278                             _transmissionIconFrame := _transmissionIconFrame % 11;
2396  0279                         endif
2397  0280                         RESET_ANIMATION_TIMER;
2398  0281                     endif
2399  0282   
2400  0283                     if (TXT_SCROLL_TIMER_TIMEOUT)
2401  0284                         scroll_text_in_selection_area();
2402  0285                         RESET_TXT_SCROLL_TIMER;
2403  0286                     endif
2404  0287                 forever
2405  0288             endfunc
2406  0289   
Notice: Check that the function called via pointer array 'tokenParsers' requires 0 arguments (line 229 file:mugDisplay.4DG)
Notice: variable 'area' is being indexed (line 251 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 226 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 227 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 228 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 228 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 229 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 229 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 237 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 238 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 239 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 239 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 240 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 240 file:mugDisplayDisplay.fnc)
Notice: variable 'str' is being indexed (line 209 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 151 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 152 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 153 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 153 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 154 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 154 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 156 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 156 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 157 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 158 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 159 file:mugDisplayDisplay.fnc)
Notice: variable 'str' is being indexed (line 102 file:mugDisplayDisplay.fnc)
Notice: variable 'str' is being indexed (line 103 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 128 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 129 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 136 file:mugDisplayDisplay.fnc)
Notice: variable 'area' is being indexed (line 137 file:mugDisplayDisplay.fnc)
Notice: variable 'bfr' is being indexed (line 81 file:mugDisplayDisplay.fnc)
Notice: variable 'txtStr' is being indexed (line 81 file:mugDisplayDisplay.fnc)
Notice: variable 'bfr' is being indexed (line 84 file:mugDisplayDisplay.fnc)
Notice: function argument 'fg_colour' in func 'clearArea' is never used (line 33 file:mugDisplayDisplay.fnc)


Symbol Table:
name                 decimal    hex
__MAXMEM                             255  0x000000ff (const dword)  (usage 1)
__MAXPROG                           9216  0x00002400 (const dword)  (usage 1)
_powerIconDisplayedState             412  0x0000019c (mem) word (global)  (usage 4)
_powerIconLevel                      414  0x0000019e (mem) word (global)  (usage 3)
_signalIconDisplayedState            416  0x000001a0 (mem) word (global)  (usage 4)
_signalIconLevel                     418  0x000001a2 (mem) word (global)  (usage 3)
_transmissionIconDisplayedState      408  0x00000198 (mem) word (global)  (usage 4)
_transmissionIconFrame               410  0x0000019a (mem) word (global)  (usage 5)
_write_str_to_window                1474  0x000005c2 (User func) args[2] r=0  (usage 2)
ANIMATION_TIMEOUT                    100  0x00000064 (const dword)  (usage 2)
ANIMATION_TIMER                      115  0x00000073 (const dword)  (usage 3)
ANIMATION_TIMER_TIMEOUT           1419848  0x0015aa48(macro)  !(*ANIMATION_TIMER)   (usage 1)
BAUD_19200                           155  0x0000009b (const dword)  (usage 1)
BG_COLOUR                              5  0x00000005 (const ??? 0)  (usage 1)
BLACK                                  0  0x00000000 (const dword)  (usage 5)
BLUE                                  31  0x0000001f (const dword)  (usage 1)
checkArgCount                       1223  0x000004c7 (User func) args[1] r=0  (usage 4)
clearArea                           2588  0x00000a1c (User func) args[6] r=0  (usage 7)
COM0                               65284  0x0000ff04 (const dword)  (usage 2)
com_AutoBaud                         -86  0xffffffaa (PmmC func) args[1] r=1  (usage 1)
com_Checksum                         -93  0xffffffa3 (PmmC func) args[0] r=1  (usage 1)
com_Count                            -89  0xffffffa7 (PmmC func) args[0] r=1  (usage 3)
com_Error                            -91  0xffffffa5 (PmmC func) args[0] r=1  (usage 1)
com_Full                             -90  0xffffffa6 (PmmC func) args[0] r=1  (usage 1)
com_Init                             -87  0xffffffa9 (PmmC func) args[3] r=0  (usage 1)
delay                             UNRESOLVED  (usage 3)
disp_BlitPixelFill                  -101  0xffffff9b (PmmC func) args[2] r=0  (usage 1)
disp_BlitPixelsFromMedia            -105  0xffffff97 (PmmC func) args[1] r=0  (usage 1)
disp_BlitPixelsToMedia              -102  0xffffff9a (PmmC func) args[0] r=1  (usage 1)
display_selected_message_parser      722  0x000002d2 (User func) args[0] r=0  (usage 1)
display_selection_text              1761  0x000006e1 (User func) args[2] r=0  (usage 1)
display_selection_text_copy         1670  0x00000686 (User func) args[2] r=0  (usage 1)
DISPLAY_SPLASH_SCREEN                  0  0x00000000 (const dword)  (usage 4)
display_text_in_area                1898  0x0000076a (User func) args[2] r=0  (usage 3)
displayIconAtPosition               2644  0x00000a54 (User func) args[5] r=0  (usage 2)
displaySplashScreen                 2478  0x000009ae (User func) args[4] r=0  (usage 1)
FALSE                                  0  0x00000000 (const dword)  (usage 23)
FG_COLOUR                              4  0x00000004 (const ??? 0)  (usage 3)
getError                            3000  0x00000bb8 (User func) args[0] r=0  (usage 2)
getNextChar                         2955  0x00000b8b (User func) args[0] r=0  (usage 6)
getStringPtr                        2991  0x00000baf (User func) args[0] r=0  (usage 2)
gfx_Clipping                        -148  0xffffff6c (PmmC func) args[1] r=0  (usage 6)
gfx_ClipWindow                       -65  0xffffffbf (PmmC func) args[4] r=0  (usage 4)
gfx_Cls                              -41  0xffffffd7 (PmmC func) args[0] r=0  (usage 4)
gfx_Contrast                        -154  0xffffff66 (PmmC func) args[1] r=0  (usage 5)
gfx_FocusWindow                      -67  0xffffffbd (PmmC func) args[0] r=1  (usage 3)
gfx_Hline                            -47  0xffffffd1 (PmmC func) args[4] r=1  (usage 2)
GOLDELOX                               1  0x00000001 (const dword)  (usage 1)
GREEN                               1024  0x00000400 (const dword)  (usage 3)
hasChars                            2965  0x00000b95 (User func) args[0] r=0  (usage 1)
hasNextChar                         2974  0x00000b9e (User func) args[0] r=0  (usage 1)
HEIGHT                                 3  0x00000003 (const ??? 0)  (usage 3)
ICON_HEIGHT                           18  0x00000012 (const dword)  (usage 4)
ICON_POWER                             1  0x00000001 (const dword)  (usage 2)
ICON_SIGNAL                            2  0x00000002 (const dword)  (usage 2)
ICON_TRANSMISSION                      3  0x00000003 (const dword)  (usage 1)
ICON_WIDTH                            20  0x00000014 (const dword)  (usage 3)
INIT_ANIMATION_TIMER              1419608  0x0015a958(macro)  *ANIMATION_TIMER := ANIMATION_TIMEOUT   (usage 2)
INIT_TXT_SCROLL_TIMER             1420064  0x0015ab20(macro)  *TXT_SCROLL_TIMER := TXT_SCROLL_TIMEOUT   (usage 2)
initCommunication                   2667  0x00000a6b (User func) args[1] r=0  (usage 1)
initScreenLayout                    1240  0x000004d8 (User func) args[0] r=0  (usage 1)
lastError                              0  0x00000000 (mem) word (global)  (usage 3)
media_Image                          -77  0xffffffb3 (PmmC func) args[2] r=0  (usage 1)
media_Init                           -79  0xffffffb1 (PmmC func) args[0] r=1  (usage 1)
media_SetSector                      -72  0xffffffb8 (PmmC func) args[2] r=0  (usage 5)
media_VideoFrame                     -70  0xffffffba (PmmC func) args[3] r=0  (usage 2)
message_window_properties            280  0x00000118 (mem) word[10] (global)  (usage 3)
MSG_BUFFER_SIZE                       32  0x00000020 (const dword)  (usage 2)
NUM_COMMANDS                           9  0x00000009 (const dword)  (usage 1)
OFF                                    0  0x00000000 (const dword)  (usage 3)
ON                                     1  0x00000001 (const dword)  (usage 3)
parseSerialBuffer                    486  0x000001e6 (User func) args[0] r=0  (usage 1)
pause                                 -6  0xfffffffa (PmmC func) args[1] r=0  (usage 5)
power_icon_max_idx                     6  0x00000006 (const ??? 0)  (usage 1)
power_icon_properties                300  0x0000012c (mem) word[6] (global)  (usage 3)
power_icon_sector                 1420464  0x0015acb0(macro)  0x0000, 0x0000   (usage 1)
print_message                       2044  0x000007fc (User func) args[2] r=0  (usage 1)
PURPLE                             32784  0x00008010 (const dword)  (usage 1)
putch                                 -2  0xfffffffe (PmmC func) args[1] r=0  (usage 2)
RED                                63488  0x0000f800 (const dword)  (usage 2)
RESET_ANIMATION_TIMER             1333376  0x00145880(macro)  INIT_ANIMATION_TIMER   (usage 1)
RESET_TXT_SCROLL_TIMER            1420216  0x0015abb8(macro)  INIT_TXT_SCROLL_TIMER   (usage 1)
resetSerialBuffer                   2847  0x00000b1f (User func) args[0] r=0  (usage 3)
scroll_blit_sector                1396064  0x00154d60(macro)  0x0020, 0x0000       /* offset 0xC400 */   (usage 2)
scroll_text_in_selection_area       1806  0x0000070e (User func) args[0] r=0  (usage 1)
scroll_text_in_selection_area.delay     406  0x00000196 (mem) word (member of scroll_text_in_selection_area)  (usage 2)
selected_message                     402  0x00000192 (mem) word (global)  (usage 7)
selected_message_buffer              336  0x00000150 (mem) word[32] (global)  (usage 3)
selected_message_offset              404  0x00000194 (mem) word (global)  (usage 7)
selection_area_properties            260  0x00000104 (mem) word[10] (global)  (usage 4)
sendAck                             2823  0x00000b07 (User func) args[0] r=0  (usage 2)
sendNAck                            2780  0x00000adc (User func) args[1] r=0  (usage 3)
SERIAL_BAUDRATE                      155  0x0000009b (const dword)  (usage 1)
serial_buffer                          4  0x00000004 (mem) word[128] (global)  (usage 2)
serial_buffer_ptr                      2  0x00000002 (mem) word (global)  (usage 4)
SERIAL_BUFFER_SIZE                   128  0x00000080 (const dword)  (usage 1)
serin                                 -1  0xffffffff (PmmC func) args[0] r=1  (usage 1)
set_contrast_parser                  593  0x00000251 (User func) args[0] r=0  (usage 1)
set_power_level_parser               804  0x00000324 (User func) args[0] r=0  (usage 1)
set_signal_level_parser              915  0x00000393 (User func) args[0] r=0  (usage 1)
setbaud                               -4  0xfffffffc (PmmC func) args[1] r=0  (usage 1)
setError                            3003  0x00000bbb (User func) args[1] r=0  (usage 12)
show_token_parser                    738  0x000002e2 (User func) args[0] r=0  (usage 1)
showIcon                            1026  0x00000402 (User func) args[2] r=0  (usage 3)
signal_icon_max_idx                    5  0x00000005 (const ??? 0)  (usage 1)
signal_icon_properties               312  0x00000138 (mem) word[6] (global)  (usage 3)
signal_icon_sector                1420576  0x0015ad20(macro)  0x0000, 0x0009   (usage 1)
SPLASH_SCREEN_DELAY                  150  0x00000096 (const dword)  (usage 1)
STR                                  128  0x00000080 (const dword)  (usage 1)
strheight                           -127  0xffffff81 (PmmC func) args[0] r=1  (usage 1)
strlen                              -123  0xffffff85 (PmmC func) args[1] r=1  (usage 6)
strwidth                            -126  0xffffff82 (PmmC func) args[1] r=1  (usage 1)
TEXT_COL                               7  0x00000007 (const ??? 0)  (usage 1)
TEXT_LINE                              6  0x00000006 (const ??? 0)  (usage 1)
TEXT_TYPE_BOLD                         8  0x00000008 (const ??? 0)  (usage 3)
text_wrap                           2376  0x00000948 (User func) args[3] r=0  (usage 2)
TEXT_WRAP                              9  0x00000009 (const ??? 0)  (usage 1)
TIMER1                               115  0x00000073 (const dword)  (usage 1)
TIMER2                               116  0x00000074 (const dword)  (usage 1)
to                                    -5  0xfffffffb (PmmC func) args[1] r=1  (usage 2)
tokenParsers                         420  0x000001a4 (mem) word[10] (global)  (usage 1)
transmission_icon_properties         324  0x00000144 (mem) word[6] (global)  (usage 3)
transmission_icon_sector          1420696  0x0015ad98(macro)  0x0000, 0x0011   (usage 1)
TRUE                                   1  0x00000001 (const dword)  (usage 17)
txt_BGcolour                        -130  0xffffff7e (PmmC func) args[1] r=0  (usage 1)
txt_Bold                            -138  0xffffff76 (PmmC func) args[1] r=0  (usage 6)
txt_FGcolour                        -129  0xffffff7f (PmmC func) args[1] r=0  (usage 7)
txt_Height                          -133  0xffffff7b (PmmC func) args[1] r=0  (usage 2)
txt_MoveCursor                       -28  0xffffffe4 (PmmC func) args[2] r=0  (usage 4)
TXT_SCROLL_TIMEOUT                   350  0x0000015e (const dword)  (usage 2)
TXT_SCROLL_TIMER                     116  0x00000074 (const dword)  (usage 3)
TXT_SCROLL_TIMER_TIMEOUT          1420344  0x0015ac38(macro)  !(*TXT_SCROLL_TIMER)   (usage 1)
txt_Width                           -132  0xffffff7c (PmmC func) args[1] r=0  (usage 2)
verifySerialBufferContents          2866  0x00000b32 (User func) args[0] r=0  (usage 1)
waitForMedia                         415  0x0000019f (User func) args[0] r=0  (usage 1)
WIDTH                                  2  0x00000002 (const ??? 0)  (usage 3)
write_message                       1381  0x00000565 (User func) args[1] r=0  (usage 1)
write_message_parser                 699  0x000002bb (User func) args[0] r=0  (usage 1)
write_selected_message              1357  0x0000054d (User func) args[0] r=0  (usage 1)
write_selected_message_parser        713  0x000002c9 (User func) args[0] r=0  (usage 1)
write_str_to_window                 1392  0x00000570 (User func) args[2] r=0  (usage 2)
X                                      0  0x00000000 (const dword)  (usage 9)
Y                                      1  0x00000001 (const ??? 0)  (usage 9)
YELLOW                             65504  0x0000ffe0 (const dword)  (usage 1)
